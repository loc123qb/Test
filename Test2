local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/Puhcoder16/theme/refs/heads/main/theme"))()
    local Window = Rayfield:CreateWindow({
   Name = "Loc dep trai",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Ez",
   LoadingSubtitle = "by Locc",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "M", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
   Enabled = true,
   FolderName = "Loccdz", -- üëà ph·∫£i ƒë·ªÉ trong d·∫•u ngo·∫∑c k√©p
   FileName = "Locc Hub"
},

        
   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local Tab = Window:CreateTab("Home", nil) -- Title, Image
local MainSection = Tab:CreateSection("Main")
local MiscTab = Window:CreateTab("Misc", nil) -- Title, Image

-- Bi·∫øn to√†n c·ª•c ƒëi·ªÅu khi·ªÉn
_G.AutoSkill = false

-- T·∫°o toggle Auto Skill
local Toggle = Tab:CreateToggle({
    Name = "Auto Skill Chain Lightning",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        _G.AutoSkill = Value
        if Value then
            print("ƒê√£ b·∫≠t Auto Skill")
            AutoSkillFunc()
        else
            print("ƒê√£ t·∫Øt Auto Skill")
        end
    end,
})

-- Auto Skill: Chain Lightning (ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu)
function AutoSkillFunc()
    task.spawn(function()
        -- N·∫øu bi·∫øn _G.ComboDone ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (kh√¥ng d√πng combo), m·∫∑c ƒë·ªãnh cho true
        if _G.ComboDone == nil then _G.ComboDone = true end

        -- Ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu (n·∫øu combo ƒëang ch·∫°y)
        repeat task.wait() until _G.ComboDone == true

        -- B·∫Øt ƒë·∫ßu loop s·ª≠ d·ª•ng skill khi _G.AutoSkill = true
        while _G.AutoSkill do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "EBD5165C-DB2C-4A41-A43C-7EC83AEB89E9" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Chain Lightning")) 
                              or (player.Character and player.Character:FindFirstChild("Chain Lightning"))
                if skill and skill:FindFirstChild("abilityEvent") then
                    skill.abilityEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoSkill] pcall error:", err)
                task.wait(0.5)
            end
        end
    end)
end


-- Bi·∫øn ƒëi·ªÅu khi·ªÉn AutoLift
_G.Autolift = false
local running = false

-- Auto Heal: Chain Heal (ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu)
local function AutoLiftFunc()
    if running then return end -- tr√°nh ch·∫°y tr√πng
    running = true
    task.spawn(function()
        -- N·∫øu bi·∫øn _G.ComboDone ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (kh√¥ng d√πng combo), m·∫∑c ƒë·ªãnh cho true
        if _G.ComboDone == nil then _G.ComboDone = true end

        -- Ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu (n·∫øu combo ƒëang ch·∫°y)
        repeat task.wait() until _G.ComboDone == true

        while _G.Autolift do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "852E0487-29F7-4293-AD32-9F02DD884A51" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Chain Heal"))
                              or (player.Character and player.Character:FindFirstChild("Chain Heal"))
                if skill and skill:FindFirstChild("spellEvent") then
                    skill.spellEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoHeal] pcall error:", err)
                task.wait(0.5)
            end
        end

        running = false
    end)
end


-- T·∫°o Toggle tr√™n GUI
local Toggle = Tab:CreateToggle({
    Name = "Auto Heal (Chain Heal)",
    CurrentValue = false,      -- m·∫∑c ƒë·ªãnh t·∫Øt
    Flag = "Toggle_AutoHeal",  -- Flag duy nh·∫•t ƒë·ªÉ l∆∞u
    Callback = function(Value)
        _G.Autolift = Value
        if Value then
            print("‚úÖ Auto Heal ƒê√É B·∫¨T")
            AutoLiftFunc()
        else
            print("‚õî Auto Heal ƒê√É T·∫ÆT")
        end
    end,
})


--// ‚ö° Auto Overcharge (theo phong c√°ch Auto Heal)
_G.AutoOvercharge = false
local running = false

-- H√†m ch√≠nh
local function AutoOverchargeFunc()
    if running then return end -- tr√°nh ch·∫°y tr√πng
    running = true
    task.spawn(function()
        -- N·∫øu c√≥ combo th√¨ ch·ªù ho√†n t·∫•t tr∆∞·ªõc khi k√≠ch ho·∫°t
        if _G.ComboDone == nil then _G.ComboDone = true end
        repeat task.wait() until _G.ComboDone == true

        while _G.AutoOvercharge do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "17314bb0-099c-461b-afb9-01ddcad548bd" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Overcharge"))
                            or (player.Character and player.Character:FindFirstChild("Overcharge"))
                if skill and skill:FindFirstChild("abilityEvent") then
                    skill.abilityEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoOvercharge] pcall error:", err)
                task.wait(0.5)
            end
        end

        running = false
    end)
end

--// üß© Toggle tr√™n GUI
local Toggle = Tab:CreateToggle({
    Name = "Auto Overcharge",
    CurrentValue = false,          -- m·∫∑c ƒë·ªãnh t·∫Øt
    Flag = "Toggle_AutoOvercharge", -- Flag duy nh·∫•t ƒë·ªÉ l∆∞u
    Callback = function(Value)
        _G.AutoOvercharge = Value
        if Value then
            print("‚úÖ Auto Overcharge ƒê√É B·∫¨T")
            AutoOverchargeFunc()
        else
            print("‚õî Auto Overcharge ƒê√É T·∫ÆT")
        end
    end,
})


-- ========= Auto Combo (1 l·∫ßn) + Toggle (l∆∞u config) =========
-- Ch√®n sau Auto Heal toggle, tr∆∞·ªõc Auto Farm

-- ƒë·∫£m b·∫£o bi·∫øn to√†n c·ª•c t·ªìn t·∫°i
_G.ComboDone = _G.ComboDone or true
_G.ComboRunning = _G.ComboRunning or false

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- an to√†n: swap set
local function swapSet(setName)
    local args = {
        [1] = {
            [1] = { ["\3"] = "swapAbilitySet" },
            [2] = setName
        }
    }
    if ReplicatedStorage:FindFirstChild("dataRemoteEvent") and type(ReplicatedStorage.dataRemoteEvent.FireServer) == "function" then
        pcall(function()
            ReplicatedStorage.dataRemoteEvent:FireServer(unpack(args))
        end)
    end
end

-- an to√†n: d√πng skill (t√¨m trong Backpack ho·∫∑c Character)
local function useSkill(skillName, skillID)
    if not player then return false end

    local function findInst(name)
        if player:FindFirstChild("Backpack") then
            local s = player.Backpack:FindFirstChild(name)
            if s then return s end
        end
        if player.Character then
            local s2 = player.Character:FindFirstChild(name)
            if s2 then return s2 end
        end
        -- fallback: t√¨m theo descendants (n·∫øu t√™n n·∫±m s√¢u)
        if player:FindFirstChild("Backpack") then
            for _,v in ipairs(player.Backpack:GetDescendants()) do
                if v.Name == name then return v end
            end
        end
        if player.Character then
            for _,v in ipairs(player.Character:GetDescendants()) do
                if v.Name == name then return v end
            end
        end
        return nil
    end

    local inst = findInst(skillName)
    if not inst then return false end

    local ev = inst:FindFirstChild("abilityEvent") or inst:FindFirstChild("spellEvent")
    if ev and type(ev.FireServer) == "function" then
        pcall(function() ev:FireServer(skillID) end)
        return true
    end

    -- n·∫øu instance b·∫£n th√¢n c√≥ FireServer (hi·∫øm)
    if type(inst.FireServer) == "function" then
        pcall(function() inst:FireServer(skillID) end)
        return true
    end

    return false
end

-- ch·∫°y combo 1 l·∫ßn, ƒë·∫∑t _G.ComboDone = true ch·ªâ khi ho√†n t·∫•t th·∫≠t s·ª±
local function RunComboOnce()
    if _G.ComboRunning then return end
    _G.ComboRunning = true
    _G.ComboDone = false -- kho√° c√°c script kh√°c

    task.spawn(function()
        local setM, setN = "M", "N"

        -- 1) ƒë·ªïi sang M
        swapSet(setM)
        task.wait(0.4) -- ƒë·ª£i swap server sync

        -- 2) d√πng Inner Focus
        local ok1 = useSkill("Inner Focus", "6D6A8BC4-B85F-4A20-B626-8AF8EF44DB9D")
        if not ok1 then warn("[AutoCombo] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ d√πng Inner Focus") end

        -- 3) ch·ªù 1s -> d√πng Innervate
        task.wait(1)
        local ok2 = useSkill("Innervate", "87C934DD-13DE-4DD2-A8BC-B3DA8C470515")
        if not ok2 then warn("[AutoCombo] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ d√πng Innervate") end

        -- 4) ch·ªù 1s -> swap set M 1 l·∫ßn n·ªØa
        task.wait(1)
        swapSet(setM)
        task.wait(0.5)

        -- 5) swap v·ªÅ set N (ban ƒë·∫ßu)
        swapSet(setN)
        task.wait(0.2)

        -- ho√†n t·∫•t
        _G.ComboDone = true
        _G.ComboRunning = false

        if Rayfield and type(Rayfield.Notify) == "function" then
            pcall(function()
                Rayfield:Notify({
                    Title = "Auto Combo",
                    Content = "Combo ho√†n t·∫•t ‚Äî scripts kh√°c s·∫Ω b·∫Øt ƒë·∫ßu.",
                    Duration = 3
                })
            end)
        else
            print("[AutoCombo] Combo ho√†n t·∫•t")
        end
    end)
end

-- Toggle (l∆∞u config b·∫±ng Flag)
local AutoComboToggle = Tab:CreateToggle({
    Name = "Auto Combo 1 L·∫ßn (Save Config)",
    CurrentValue = false,
    Flag = "AutoComboOnce",
    Callback = function(Value)
        if Value then
            -- khi b·∫≠t toggle: ch·∫°y 1 l·∫ßn
            RunComboOnce()
        end
    end,
})

-- Khi load script n·∫øu Flag ƒë√£ b·∫≠t (ƒë∆∞·ª£c l∆∞u) -> t·ª± ch·∫°y 1 l·∫ßn
task.defer(function()
    task.wait(1)
    if Rayfield and Rayfield.Flags and Rayfield.Flags.AutoComboOnce and Rayfield.Flags.AutoComboOnce.CurrentValue == true then
        -- n·∫øu combo ch∆∞a ch·∫°y th√¨ ch·∫°y 1 l·∫ßn
        if not _G.ComboRunning and _G.ComboDone ~= true then
            RunComboOnce()
        elseif not _G.ComboRunning and _G.ComboDone == true then
            -- n·∫øu ComboDone ƒë√£ true (kh√¥ng c·∫ßn ch·∫°y), ƒë·∫£m b·∫£o combo tr·∫°ng th√°i OK
        else
            -- ƒëang ch·∫°y, ƒë·ª£i xong
        end
    end
end)
-- ========= END =========


--// üåä AUTO FARM DUNGEON QUEST - Stable Hover + Boss Priority (Final Single Version)
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- CONFIG (tweak n·∫øu c·∫ßn)
_G.AutoTween = false
local hoverHeight = 6            -- cao h∆°n b·ªÅ m·∫∑t ƒë·ªÉ hover (studs)
local behindDistance = 8         -- ƒë·ª©ng c√°ch sau l∆∞ng NPC (studs)
local preTeleportDistance = 50   -- teleport ƒë·∫øn c√°ch NPC kho·∫£ng n√†y tr∆∞·ªõc khi di chuy·ªÉn m∆∞·ª£t
local avoidDistance = 20         -- l√πi ra khi n√© skill
local updateDelay = 1.0          -- v√≤ng l·∫∑p ch√≠nh (gi√¢y)
local maxRange = 4000
local tweenStep = 12             -- k√≠ch th∆∞·ªõc m·ªói b∆∞·ªõc tween (studs). Gi·∫£m n·∫øu c·∫ßn m∆∞·ª£t h∆°n
local tweenSpeed = 30            -- tham s·ªë quy·∫øt ƒë·ªãnh timePerStep
local minTimePerStep = 0.06      -- th·ªùi gian t·ªëi thi·ªÉu m·ªói b∆∞·ªõc (gi·∫£m ‚Üí nhanh h∆°n)
local maxTimePerStep = 0.28      -- th·ªùi gian t·ªëi ƒëa m·ªói b∆∞·ªõc (tƒÉng ‚Üí ch·∫≠m h∆°n)
local reactionWait = 1.2         -- th·ªùi gian ch·ªù sau khi n√© animation

-- tr·∫°ng th√°i
local currentTarget = nil
local reacting = false
local spawnPoint = nil

-- ===== helper
local function getHumanoidAndRoot(model)
	if not model or not model:IsA("Model") then return end
	local hum = model:FindFirstChildOfClass("Humanoid")
	local root = model:FindFirstChild("HumanoidRootPart")
	if hum and root then return hum, root end
end

local function isPlayerModel(model)
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr.Character == model then return true end
	end
	return false
end

-- ki·ªÉm tra NPC ƒë√£ spawn ƒë·ªß (hum + hrp + ch·∫°m ƒë·∫•t)
local function isNPCReady(npc)
	local hum, hrp = getHumanoidAndRoot(npc)
	if not hum or not hrp or hum.Health <= 0 then return false end
	local ray = Ray.new(hrp.Position, Vector3.new(0, -12, 0))
	local hit = Workspace:FindPartOnRay(ray, npc)
	return hit ~= nil
end

-- t√¨m target: ∆∞u ti√™n boss g·∫ßn nh·∫•t, n·∫øu kh√¥ng c√≥ th√¨ qu√°i g·∫ßn nh·∫•t
local function getNearestTarget()
	local char = LocalPlayer.Character
	if not char then return end
	local _, root = getHumanoidAndRoot(char)
	if not root then return end

	local nearest, nearestDist = nil, math.huge
	local bossTarget, bossDist = nil, math.huge

	local function scanContainer(container)
		if not container then return end
		for _, v in ipairs(container:GetChildren()) do
			if v:IsA("Model") and v ~= char and not isPlayerModel(v) then
				local hum, hrp = getHumanoidAndRoot(v)
				if hum and hrp and hum.Health > 0 and isNPCReady(v) then
					local dist = (hrp.Position - root.Position).Magnitude
					if dist < maxRange then
						local n = v.Name:lower()
						if n:find("boss") or n:find("guardian") or n:find("king") or n:find("lord") or n:find("final") or n:find("beast") then
							if dist < bossDist then bossDist = dist; bossTarget = v end
						elseif dist < nearestDist then
							nearestDist = dist; nearest = v
						end
					end
				end
			end
		end
	end

	-- qu√©t c√°c folder th∆∞·ªùng g·∫∑p tr∆∞·ªõc
	scanContainer(Workspace:FindFirstChild("Enemies"))
	scanContainer(Workspace:FindFirstChild("Mobs"))
	-- fallback to√†n b·ªô Workspace n·∫øu ch∆∞a t√¨m th·∫•y
	if not bossTarget and not nearest then
		for _, v in ipairs(Workspace:GetDescendants()) do
			if v:IsA("Model") and v ~= char and not isPlayerModel(v) then
				local hum, hrp = getHumanoidAndRoot(v)
				if hum and hrp and hum.Health > 0 and isNPCReady(v) then
					local dist = (hrp.Position - root.Position).Magnitude
					if dist < maxRange then
						local n = v.Name:lower()
						if n:find("boss") and dist < bossDist then bossDist = dist; bossTarget = v end
						if dist < nearestDist then nearestDist = dist; nearest = v end
					end
				end
			end
		end
	end

	return bossTarget or nearest
end

-- ƒë·∫£m b·∫£o v·ªã tr√≠ hover (d√≤ m·∫∑t ƒë·∫•t n·∫øu c√≥)
local function ensureHoverPos(pos)
	local ray = Ray.new(pos + Vector3.new(0, 12, 0), Vector3.new(0, -80, 0))
	local hit, hitPos = Workspace:FindPartOnRay(ray)
	if hit and hitPos then
		return Vector3.new(pos.X, hitPos.Y + hoverHeight, pos.Z)
	end
	return Vector3.new(pos.X, pos.Y + hoverHeight, pos.Z)
end

-- di chuy·ªÉn m∆∞·ª£t b·∫±ng nhi·ªÅu tween nh·ªè (gi·∫£m kh·∫£ nƒÉng b·ªã anti-cheat)
local function moveSmoothlyTo(targetPos)
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if not (hum and root) then return end

	-- tr√°nh v·ªã tr√≠ qu√° th·∫•p b·∫•t th∆∞·ªùng
	if targetPos.Y < -120 then targetPos = Vector3.new(targetPos.X, -10, targetPos.Z) end

	local startPos = root.Position
	local delta = targetPos - startPos
	local dist = delta.Magnitude
	if dist <= 0.5 then
		root.CFrame = CFrame.new(targetPos)
		return
	end

	local dir = delta.Unit
	local steps = math.max(1, math.ceil(dist / tweenStep))
	local timePerStep = math.clamp((tweenStep / tweenSpeed), minTimePerStep, maxTimePerStep)

	for i = 1, steps do
		if not _G.AutoTween then return end
		local nextPos
		if i == steps then
			nextPos = targetPos
		else
			nextPos = startPos + dir * (tweenStep * i)
		end
		nextPos = ensureHoverPos(nextPos)

		-- t·∫°o tween ng·∫Øn
		local ok, tween = pcall(function()
			return TweenService:Create(root, TweenInfo.new(timePerStep, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {CFrame = CFrame.new(nextPos)})
		end)
		if ok and tween then
			tween:Play()
			tween.Completed:Wait()
		else
			-- fallback set tr·ª±c ti·∫øp khi tween fail
			root.CFrame = CFrame.new(nextPos)
			task.wait(timePerStep)
		end

		-- an to√†n: n·∫øu r∆°i ra ngo√†i map th√¨ reset l√™n
		if root.Position.Y < -30 then
			root.CFrame = CFrame.new(root.Position.X, 5 + hoverHeight, root.Position.Z)
		end

		task.wait(0.02)
	end
end

-- teleport 1 l·∫ßn ƒë·∫øn v·ªã tr√≠ g·∫ßn NPC (pre-teleport), d√πng ƒë·ªÉ b·∫Øt ƒë·∫ßu moveSmoothlyTo
local function teleportNearTarget(target)
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	local _, tRoot = getHumanoidAndRoot(target)
	if not (hum and root and tRoot) then return end

	local dir = tRoot.Position - root.Position
	if dir.Magnitude == 0 then dir = Vector3.new(0,0,1) end
	local unitDir = dir.Unit
	local nearPos = tRoot.Position - unitDir * preTeleportDistance
	nearPos = ensureHoverPos(nearPos)
	-- teleport 1 l·∫ßn (ƒë·ªß an to√†n v√¨ c√≤n xa)
	root.CFrame = CFrame.new(nearPos, tRoot.Position)
end

-- hover m∆∞·ª£t v√†o ph√≠a sau l∆∞ng NPC
local function hoverBehindTarget(npc)
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	local _, npcRoot = getHumanoidAndRoot(npc)
	if not (hum and root and npcRoot) then return end

	local behindPos = npcRoot.Position - npcRoot.CFrame.LookVector * behindDistance
	behindPos = ensureHoverPos(behindPos)
	moveSmoothlyTo(behindPos)
	-- gi·ªØ PlatformStand ƒë·ªÉ tr√°nh physics b·ªã ƒë·∫©y
	pcall(function() hum.PlatformStand = true end)
end

-- setup reaction: n·∫øu NPC ch∆°i animation charge/attack th√¨ teleport l√πi an to√†n
local function setupBossReaction(npc)
	local hum, hrp = getHumanoidAndRoot(npc)
	if not (hum and hrp) then return end

	-- disconnect c≈© n·∫øu c√≥
	if npc.__ReactionConn and type(npc.__ReactionConn.Disconnect) == "function" then
		pcall(function() npc.__ReactionConn:Disconnect() end)
		npc.__ReactionConn = nil
	end

	local conn = hum.AnimationPlayed:Connect(function(track)
		if not _G.AutoTween then return end
		if currentTarget ~= npc then return end
		if reacting then return end
		local animName = ""
		if track and track.Animation and track.Animation.Name then animName = tostring(track.Animation.Name):lower() end
		if animName:find("attack") or animName:find("charge") or animName:find("slam") or animName:find("cast") or animName:find("telegraph") then
			reacting = true
			task.spawn(function()
				-- teleport l√πi an to√†n 1 l·∫ßn
				local playerChar = LocalPlayer.Character
				local phum, proot = getHumanoidAndRoot(playerChar)
				local _, npcRoot2 = getHumanoidAndRoot(npc)
				if phum and proot and npcRoot2 then
					local safePos = npcRoot2.Position - npcRoot2.CFrame.LookVector * (behindDistance + avoidDistance)
					safePos = ensureHoverPos(safePos)
					proot.CFrame = CFrame.new(safePos, npcRoot2.Position)
					-- ƒë·∫£m b·∫£o hover
					pcall(function() phum.PlatformStand = true end)
				end
				task.wait(reactionWait)
				reacting = false
			end)
		end
	end)

	npc.__ReactionConn = conn
end

-- ghi spawn point ƒë·ªÉ v·ªÅ khi map tr·ªëng
local function setSpawnPoint()
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if root then spawnPoint = root.Position end
end

-- quay v·ªÅ spawn khi kh√¥ng c√≥ NPC
local function returnToSpawn()
	if not spawnPoint then return end
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if not (hum and root) then return end
	local target = spawnPoint + Vector3.new(0, hoverHeight, 0)
	moveSmoothlyTo(target)
	pcall(function() hum.PlatformStand = true end)
end

-- cleanup khi t·∫Øt
local function cleanup()
	if currentTarget and currentTarget.__ReactionConn and type(currentTarget.__ReactionConn.Disconnect) == "function" then
		pcall(function() currentTarget.__ReactionConn:Disconnect() end)
		currentTarget.__ReactionConn = nil
	end
	currentTarget = nil
	reacting = false
end

-- MAIN LOOP (an to√†n)
task.spawn(function()
	setSpawnPoint()
	while true do
		task.wait(updateDelay)
		if not _G.AutoTween then
			task.wait(0.2)
		else
			local npc = getNearestTarget()
			if npc and isNPCReady(npc) then
				if npc ~= currentTarget then
					-- thay target m·ªõi: disconnect c≈©, setup reaction, teleport g·∫ßn
					cleanup()
					currentTarget = npc
					pcall(function() setupBossReaction(npc) end)
					pcall(function() teleportNearTarget(npc) end)
					task.wait(0.45) -- ƒë·ª£i sync server 0.45s
				end
				-- hover m∆∞·ª£t v√†o sau l∆∞ng
				pcall(function() hoverBehindTarget(npc) end)
			else
				-- kh√¥ng c√≥ npc ‚Üí v·ªÅ spawn v√† ch·ªù
				pcall(function() cleanup() end)
				pcall(function() returnToSpawn() end)
			end
		end
	end
end)

-- TOGGLE: g·∫Øn v√†o Rayfield Tab (gi·ªØ t√™n toggle nh∆∞ y√™u c·∫ßu)
local ToggleFarm = Tab:CreateToggle({
	Name = "Auto Farm (Hover Safe + Full)",
	CurrentValue = false,
	Flag = "ToggleAutoFarm",
	Callback = function(Value)
		_G.AutoTween = Value
		local char = LocalPlayer.Character
		local hum, root = getHumanoidAndRoot(char)
		if not (hum and root) then return end

		if Value then
			pcall(function()
				hum.PlatformStand = true
				hum:ChangeState(Enum.HumanoidStateType.Physics)
			end)
			warn("[AUTO-FARM] ‚úÖ ƒê√£ b·∫≠t: Hover c·ªë ƒë·ªãnh + Farm (∆∞u ti√™n boss).")
		else
			pcall(function()
				hum.PlatformStand = false
				hum:ChangeState(Enum.HumanoidStateType.GettingUp)
			end)
			cleanup()
			warn("[AUTO-FARM] ‚õî ƒê√£ t·∫Øt.")
		end
	end
})




local Toggle = MiscTab:CreateToggle({
	Name = "Auto Start",
	CurrentValue = false,
	Flag = "Toggle_AutoStart",
	Callback = function(Value)
		_G.AutoStart = Value

		if _G.AutoStart then
			warn("‚úÖ Auto Start ƒê√É B·∫¨T")

			-- üîÅ Ch·∫°y li√™n t·ª•c cho ƒë·∫øn khi t·∫Øt
			task.spawn(function()
            repeat task.wait() until _G.ComboDone == true

				while _G.AutoStart do
					-- ‚ö° G·ª≠i l·ªánh start
					game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer()
					warn("üîÅ Auto Start ƒëang th·ª±c thi...")

					-- ‚è± Ch·ªù 1‚Äì2 gi√¢y ƒë·ªÉ tr√°nh spam server
					task.wait(2)
				end
				warn("‚õî Auto Start ƒê√É D·ª™NG")
			end)

		else
			warn("‚õî Auto Start ƒê√É T·∫ÆT TH·ª¶ C√îNG")
		end
	end,
})


--// üß© Auto Bonus Boss
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local dataRemoteEvent = ReplicatedStorage:WaitForChild("dataRemoteEvent")

_G.AutoBonusBoss = false

local AutoBonus = MiscTab:CreateToggle({
    Name = "Auto Bonus Boss",
    CurrentValue = false,
    Flag = "AutoBonusBoss",
    Callback = function(Value)
        _G.AutoBonusBoss = Value
        if Value then
            task.spawn(function()
                while _G.AutoBonusBoss do
                    task.wait(1)
                    local bonusAvailable = false

                    -- Ki·ªÉm tra n·∫øu server c√≥ th·ªÉ vote "bonus"
                    for _, remote in pairs(ReplicatedStorage:GetChildren()) do
                        if remote.Name == "dataRemoteEvent" then
                            bonusAvailable = true
                            break
                        end
                    end

                    -- N·∫øu c√≥ bonus ‚Üí vote bonus
                    if bonusAvailable then
                        dataRemoteEvent:FireServer({
                            {
                                ["\3"] = "vote",
                                vote = "bonus"
                            },
                            "-"
                        })
                        task.wait(1) -- ch·ªù x√≠u ƒë·ªÉ bonus x·ª≠ l√Ω xong
                    end
                end
            end)
        end
    end,
})

--// ‚öôÔ∏è T√≠ch h·ª£p ∆∞u ti√™n AutoBonusBoss tr∆∞·ªõc AutoRetry
-- Gi·∫£ s·ª≠ AutoRetry c√≥ bi·∫øn _G.AutoRetry
task.spawn(function()
    while task.wait(1) do
        if _G.AutoRetry then
            if _G.AutoBonusBoss then
                -- N·∫øu bonus c√≥ s·∫µn th√¨ ∆∞u ti√™n vote tr∆∞·ªõc khi retry
                local bonusAvailable = false
                for _, remote in pairs(ReplicatedStorage:GetChildren()) do
                    if remote.Name == "dataRemoteEvent" then
                        bonusAvailable = true
                        break
                    end
                end

                if bonusAvailable then
                    dataRemoteEvent:FireServer({
                        {
                            ["\3"] = "vote",
                            vote = "bonus"
                        },
                        "-"
                    })
                    task.wait(1.5) -- ƒê·ª£i x·ª≠ l√Ω bonus
                end
            end

            -- Ti·∫øp t·ª•c auto retry b√¨nh th∆∞·ªùng
            pcall(function()
                local retryRemote = ReplicatedStorage:FindFirstChild("retryRemoteEvent") or ReplicatedStorage:FindFirstChild("Retry")
                if retryRemote then
                    retryRemote:FireServer()
                end
            end)
        end
    end
end)



local Toggle = MiscTab:CreateToggle({
	Name = "Auto Retry",
	CurrentValue = false,
	Flag = "Toggle_AutoRetry",
	Callback = function(Value)
		_G.AutoRetry = Value

		if _G.AutoRetry then
			warn("‚úÖ Auto Retry ƒê√É B·∫¨T")

			-- üîÅ Ch·∫°y li√™n t·ª•c cho ƒë·∫øn khi t·∫Øt
			task.spawn(function()
				while _G.AutoRetry do
					-- ‚ö° G·ª≠i l·ªánh retry
					local args = {
                        [1] = {
                            [1] = {
                                ["\3"] = "vote",
                                ["vote"] = true
                            },
                            [2] = "-"
                        }
                    }

                    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
					warn("üîÅ Auto Retry ƒëang th·ª±c thi...")

					-- ‚è± Ch·ªù 1‚Äì2 gi√¢y ƒë·ªÉ tr√°nh spam server
					task.wait(2)
				end
				warn("‚õî Auto Retry ƒê√É D·ª™NG")
			end)

		else
			warn("‚õî Auto Retry ƒê√É T·∫ÆT TH·ª¶ C√îNG")
		end
	end,
})

---- ‚öôÔ∏è FIX LAG (T√≠ch h·ª£p v√†o Misc Tab)
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local active = false
local saved = {}

-- üåà L∆∞u c·∫•u h√¨nh √°nh s√°ng g·ªëc
local function saveOriginal()
    saved.Lighting = {
        Technology = Lighting.Technology,
        GlobalShadows = Lighting.GlobalShadows,
        Brightness = Lighting.Brightness,
        FogEnd = Lighting.FogEnd
    }
end

-- üîÑ Kh√¥i ph·ª•c c·∫•u h√¨nh √°nh s√°ng g·ªëc
local function restoreOriginal()
    if not saved.Lighting then return end
    Lighting.Technology = saved.Lighting.Technology
    Lighting.GlobalShadows = saved.Lighting.GlobalShadows
    Lighting.Brightness = saved.Lighting.Brightness
    Lighting.FogEnd = saved.Lighting.FogEnd
end

-- üí® H√†m gi·∫£m hi·ªáu ·ª©ng t·ª´ng ƒë·ªëi t∆∞·ª£ng
local function minimize(obj)
    if obj:IsA("ParticleEmitter") or obj:IsA("Beam") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
        obj.Enabled = false
    end

    if obj:IsA("Explosion") then
        obj.Visible = false
    end

    if obj:IsA("BasePart") then
        obj.Material = Enum.Material.SmoothPlastic
        obj.Reflectance = 0
        obj.CastShadow = false
        obj.Color = Color3.fromRGB(200,200,200)
    end

    if obj:IsA("Decal") or obj:IsA("Texture") then
        obj.Transparency = 1
    end

    if obj:IsA("Sound") then
        obj.Volume = 0
        obj:Stop()
    end

    if obj:IsA("Light") then
        obj.Enabled = false
    end
end

-- üöÄ √Åp d·ª•ng ch·∫ø ƒë·ªô gi·∫£m lag
local function applyLiteMode()
    Lighting.Technology = Enum.Technology.Compatibility
    Lighting.GlobalShadows = false
    Lighting.Brightness = 1
    Lighting.FogEnd = 999999999

    for _, obj in ipairs(Workspace:GetDescendants()) do
        minimize(obj)
    end

    Workspace.DescendantAdded:Connect(function(obj)
        if active then minimize(obj) end
    end)
end

-- üß© B·∫≠t/T·∫Øt FixLag
local function toggleFixLag(on)
    active = on
    if on then
        saveOriginal()
        applyLiteMode()
        warn("‚úÖ Fix Lag LITE: ON")
    else
        restoreOriginal()
        warn("‚õî Fix Lag LITE: OFF (b·∫°n c√≥ th·ªÉ c·∫ßn rejoin ƒë·ªÉ kh√¥i ph·ª•c ho√†n to√†n)")
    end
end

-- üéõÔ∏è Th√™m Toggle v√†o Misc Tab
local ToggleFixLag = MiscTab:CreateToggle({
    Name = "Fix Lag (Lite Mode)",
    CurrentValue = false,
    Flag = "Toggle_FixLag",
    Callback = function(Value)
        toggleFixLag(Value)
    end,
})





local WalkspeedInput = MiscTab:CreateInput({
    Name = "Walkspeed Input",
    PlaceholderText = "Nh·∫≠p t·ªëc ƒë·ªô (VD: 100)",
    CurrentValue = "16",
    RemoveTextAfterFocusLost = false,
    Flag = "Walkspeed_Input",

    Callback = function(Text)
        local Speed = tonumber(Text)
        if not Speed then
            warn("‚ùå H√£y nh·∫≠p s·ªë h·ª£p l·ªá!")
            return
        end

        Speed = math.clamp(Speed, 0, 300)

        local player = game.Players.LocalPlayer
        local humanoid = player and player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = Speed
            warn("‚úÖ ƒê·∫∑t t·ªëc ƒë·ªô th√†nh:", Speed)
        end
    end,
})

-- üß† Th√™m s·ª± ki·ªán auto-clear khi click v√†o textbox
task.spawn(function()
    task.wait(1) -- ƒë·ª£i UI load xong
    local box = WalkspeedInput.InputBox or WalkspeedInput.TextBox or WalkspeedInput

    if box and box.FocusGained then
        box.FocusGained:Connect(function()
            box.Text = "" -- xo√° n·ªôi dung hi·ªán t·∫°i khi click v√†o
        end)
    else
        warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y TextBox (c√≥ th·ªÉ UI lib c·ªßa b·∫°n d√πng t√™n kh√°c)")
    end
end)

-- üß† T·ª± ƒë·ªông kh√¥i ph·ª•c l·∫°i tr·∫°ng th√°i Toggle/Input khi m·ªü l·∫°i game
task.spawn(function()
    task.wait(1) -- ƒë·ª£i UI load ho√†n t·∫•t
    Rayfield.LoadConfiguration() -- kh√¥i ph·ª•c m·ªçi gi√° tr·ªã ƒë√£ l∆∞u
end)
