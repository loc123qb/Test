local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/Puhcoder16/theme/refs/heads/main/theme"))()
    local Window = Rayfield:CreateWindow({
   Name = "Loc dep trai",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Ez",
   LoadingSubtitle = "by Locc",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "M", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
   Enabled = true,
   FolderName = "Loccdz", -- üëà ph·∫£i ƒë·ªÉ trong d·∫•u ngo·∫∑c k√©p
   FileName = "Locc Hub"
},

        
   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local Tab = Window:CreateTab("Home", nil) -- Title, Image
local MainSection = Tab:CreateSection("Main")
local MiscTab = Window:CreateTab("Misc", nil) -- Title, Image

-- Bi·∫øn to√†n c·ª•c ƒëi·ªÅu khi·ªÉn
_G.AutoSkill = false

-- T·∫°o toggle Auto Skill
local Toggle = Tab:CreateToggle({
    Name = "Auto Skill Chain Lightning",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        _G.AutoSkill = Value
        if Value then
            print("ƒê√£ b·∫≠t Auto Skill")
            AutoSkillFunc()
        else
            print("ƒê√£ t·∫Øt Auto Skill")
        end
    end,
})

-- Auto Skill: Chain Lightning (ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu)
function AutoSkillFunc()
    task.spawn(function()
        -- N·∫øu bi·∫øn _G.ComboDone ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (kh√¥ng d√πng combo), m·∫∑c ƒë·ªãnh cho true
        if _G.ComboDone == nil then _G.ComboDone = true end

        -- Ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu (n·∫øu combo ƒëang ch·∫°y)
        repeat task.wait() until _G.ComboDone == true

        -- B·∫Øt ƒë·∫ßu loop s·ª≠ d·ª•ng skill khi _G.AutoSkill = true
        while _G.AutoSkill do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "EBD5165C-DB2C-4A41-A43C-7EC83AEB89E9" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Chain Lightning")) 
                              or (player.Character and player.Character:FindFirstChild("Chain Lightning"))
                if skill and skill:FindFirstChild("abilityEvent") then
                    skill.abilityEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoSkill] pcall error:", err)
                task.wait(0.5)
            end
        end
    end)
end


-- Bi·∫øn ƒëi·ªÅu khi·ªÉn AutoLift
_G.Autolift = false
local running = false

-- Auto Heal: Chain Heal (ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu)
local function AutoLiftFunc()
    if running then return end -- tr√°nh ch·∫°y tr√πng
    running = true
    task.spawn(function()
        -- N·∫øu bi·∫øn _G.ComboDone ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (kh√¥ng d√πng combo), m·∫∑c ƒë·ªãnh cho true
        if _G.ComboDone == nil then _G.ComboDone = true end

        -- Ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu (n·∫øu combo ƒëang ch·∫°y)
        repeat task.wait() until _G.ComboDone == true

        while _G.Autolift do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "852E0487-29F7-4293-AD32-9F02DD884A51" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Chain Heal"))
                              or (player.Character and player.Character:FindFirstChild("Chain Heal"))
                if skill and skill:FindFirstChild("spellEvent") then
                    skill.spellEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoHeal] pcall error:", err)
                task.wait(0.5)
            end
        end

        running = false
    end)
end


-- T·∫°o Toggle tr√™n GUI
local Toggle = Tab:CreateToggle({
    Name = "Auto Heal (Chain Heal)",
    CurrentValue = false,      -- m·∫∑c ƒë·ªãnh t·∫Øt
    Flag = "Toggle_AutoHeal",  -- Flag duy nh·∫•t ƒë·ªÉ l∆∞u
    Callback = function(Value)
        _G.Autolift = Value
        if Value then
            print("‚úÖ Auto Heal ƒê√É B·∫¨T")
            AutoLiftFunc()
        else
            print("‚õî Auto Heal ƒê√É T·∫ÆT")
        end
    end,
})


--// ‚ö° Auto Overcharge (theo phong c√°ch Auto Heal)
_G.AutoOvercharge = false
local running = false

-- H√†m ch√≠nh
local function AutoOverchargeFunc()
    if running then return end -- tr√°nh ch·∫°y tr√πng
    running = true
    task.spawn(function()
        -- N·∫øu c√≥ combo th√¨ ch·ªù ho√†n t·∫•t tr∆∞·ªõc khi k√≠ch ho·∫°t
        if _G.ComboDone == nil then _G.ComboDone = true end
        repeat task.wait() until _G.ComboDone == true

        while _G.AutoOvercharge do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "17314bb0-099c-461b-afb9-01ddcad548bd" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Overcharge"))
                            or (player.Character and player.Character:FindFirstChild("Overcharge"))
                if skill and skill:FindFirstChild("abilityEvent") then
                    skill.abilityEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoOvercharge] pcall error:", err)
                task.wait(0.5)
            end
        end

        running = false
    end)
end

--// üß© Toggle tr√™n GUI
local Toggle = Tab:CreateToggle({
    Name = "Auto Overcharge",
    CurrentValue = false,          -- m·∫∑c ƒë·ªãnh t·∫Øt
    Flag = "Toggle_AutoOvercharge", -- Flag duy nh·∫•t ƒë·ªÉ l∆∞u
    Callback = function(Value)
        _G.AutoOvercharge = Value
        if Value then
            print("‚úÖ Auto Overcharge ƒê√É B·∫¨T")
            AutoOverchargeFunc()
        else
            print("‚õî Auto Overcharge ƒê√É T·∫ÆT")
        end
    end,
})


-- ========= Auto Combo (1 l·∫ßn) + Toggle (l∆∞u config) =========
-- Ch√®n sau Auto Heal toggle, tr∆∞·ªõc Auto Farm

-- ƒë·∫£m b·∫£o bi·∫øn to√†n c·ª•c t·ªìn t·∫°i
_G.ComboDone = _G.ComboDone or true
_G.ComboRunning = _G.ComboRunning or false

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- an to√†n: swap set
local function swapSet(setName)
    local args = {
        [1] = {
            [1] = { ["\3"] = "swapAbilitySet" },
            [2] = setName
        }
    }
    if ReplicatedStorage:FindFirstChild("dataRemoteEvent") and type(ReplicatedStorage.dataRemoteEvent.FireServer) == "function" then
        pcall(function()
            ReplicatedStorage.dataRemoteEvent:FireServer(unpack(args))
        end)
    end
end

-- an to√†n: d√πng skill (t√¨m trong Backpack ho·∫∑c Character)
local function useSkill(skillName, skillID)
    if not player then return false end

    local function findInst(name)
        if player:FindFirstChild("Backpack") then
            local s = player.Backpack:FindFirstChild(name)
            if s then return s end
        end
        if player.Character then
            local s2 = player.Character:FindFirstChild(name)
            if s2 then return s2 end
        end
        -- fallback: t√¨m theo descendants (n·∫øu t√™n n·∫±m s√¢u)
        if player:FindFirstChild("Backpack") then
            for _,v in ipairs(player.Backpack:GetDescendants()) do
                if v.Name == name then return v end
            end
        end
        if player.Character then
            for _,v in ipairs(player.Character:GetDescendants()) do
                if v.Name == name then return v end
            end
        end
        return nil
    end

    local inst = findInst(skillName)
    if not inst then return false end

    local ev = inst:FindFirstChild("abilityEvent") or inst:FindFirstChild("spellEvent")
    if ev and type(ev.FireServer) == "function" then
        pcall(function() ev:FireServer(skillID) end)
        return true
    end

    -- n·∫øu instance b·∫£n th√¢n c√≥ FireServer (hi·∫øm)
    if type(inst.FireServer) == "function" then
        pcall(function() inst:FireServer(skillID) end)
        return true
    end

    return false
end

-- ch·∫°y combo 1 l·∫ßn, ƒë·∫∑t _G.ComboDone = true ch·ªâ khi ho√†n t·∫•t th·∫≠t s·ª±
local function RunComboOnce()
    if _G.ComboRunning then return end
    _G.ComboRunning = true
    _G.ComboDone = false -- kho√° c√°c script kh√°c

    task.spawn(function()
        local setM, setN = "M", "N"

        -- 1) ƒë·ªïi sang M
        swapSet(setM)
        task.wait(0.4) -- ƒë·ª£i swap server sync

        -- 2) d√πng Inner Focus
        local ok1 = useSkill("Inner Focus", "6D6A8BC4-B85F-4A20-B626-8AF8EF44DB9D")
        if not ok1 then warn("[AutoCombo] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ d√πng Inner Focus") end

        -- 3) ch·ªù 1s -> d√πng Innervate
        task.wait(1)
        local ok2 = useSkill("Innervate", "87C934DD-13DE-4DD2-A8BC-B3DA8C470515")
        if not ok2 then warn("[AutoCombo] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ d√πng Innervate") end

        -- 4) ch·ªù 1s -> swap set M 1 l·∫ßn n·ªØa
        task.wait(1)
        swapSet(setM)
        task.wait(0.5)

        -- 5) swap v·ªÅ set N (ban ƒë·∫ßu)
        swapSet(setN)
        task.wait(0.2)

        -- ho√†n t·∫•t
        _G.ComboDone = true
        _G.ComboRunning = false

        if Rayfield and type(Rayfield.Notify) == "function" then
            pcall(function()
                Rayfield:Notify({
                    Title = "Auto Combo",
                    Content = "Combo ho√†n t·∫•t ‚Äî scripts kh√°c s·∫Ω b·∫Øt ƒë·∫ßu.",
                    Duration = 3
                })
            end)
        else
            print("[AutoCombo] Combo ho√†n t·∫•t")
        end
    end)
end

-- Toggle (l∆∞u config b·∫±ng Flag)
local AutoComboToggle = Tab:CreateToggle({
    Name = "Auto Combo 1 L·∫ßn (Save Config)",
    CurrentValue = false,
    Flag = "AutoComboOnce",
    Callback = function(Value)
        if Value then
            -- khi b·∫≠t toggle: ch·∫°y 1 l·∫ßn
            RunComboOnce()
        end
    end,
})

-- Khi load script n·∫øu Flag ƒë√£ b·∫≠t (ƒë∆∞·ª£c l∆∞u) -> t·ª± ch·∫°y 1 l·∫ßn
task.defer(function()
    task.wait(1)
    if Rayfield and Rayfield.Flags and Rayfield.Flags.AutoComboOnce and Rayfield.Flags.AutoComboOnce.CurrentValue == true then
        -- n·∫øu combo ch∆∞a ch·∫°y th√¨ ch·∫°y 1 l·∫ßn
        if not _G.ComboRunning and _G.ComboDone ~= true then
            RunComboOnce()
        elseif not _G.ComboRunning and _G.ComboDone == true then
            -- n·∫øu ComboDone ƒë√£ true (kh√¥ng c·∫ßn ch·∫°y), ƒë·∫£m b·∫£o combo tr·∫°ng th√°i OK
        else
            -- ƒëang ch·∫°y, ƒë·ª£i xong
        end
    end
end)
-- ========= END =========


--// üåä Auto Farm Hover Tween - Smooth Behind NPC (Stable for All Dungeon Quest Maps)
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- ‚öôÔ∏è C·∫•u h√¨nh
local tweenSpeed = 55 -- t·ªëc ƒë·ªô di chuy·ªÉn
local hoverHeight = 0
local teleportDistance = 8 -- kho·∫£ng c√°ch ph√≠a sau qu√°i
local updateDelay = 1.25 -- th·ªùi gian delay gi·ªØa m·ªói l·∫ßn t√¨m NPC
local maxRange = 4000

_G.AutoTween = false

-- üß† H√†m h·ªó tr·ª£
local function getHumanoidAndRoot(model)
	if not model then return end
	local hum = model:FindFirstChildOfClass("Humanoid")
	local root = model:FindFirstChild("HumanoidRootPart")
	return hum, root
end

local function isPlayerModel(model)
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr.Character == model then
			return true
		end
	end
	return false
end

-- üîç ∆Øu ti√™n Boss tr∆∞·ªõc, sau ƒë√≥ qu√°i g·∫ßn nh·∫•t
local function getNearestNPC()
	local char = LocalPlayer.Character
	if not char then return end
	local _, root = getHumanoidAndRoot(char)
	if not root then return end

	local npcFolders = {Workspace:FindFirstChild("Enemies"), Workspace:FindFirstChild("Mobs")}
	local nearestBoss, nearestEnemy
	local shortestBoss, shortestEnemy = math.huge, math.huge

	for _, folder in ipairs(npcFolders) do
		if folder then
			for _, v in ipairs(folder:GetChildren()) do
				if v:IsA("Model") and v ~= char then
					local hum, hrp = getHumanoidAndRoot(v)
					if hum and hrp and hum.Health > 0 and not isPlayerModel(v) then
						local dist = (hrp.Position - root.Position).Magnitude
						if dist < maxRange then
							local lowerName = v.Name:lower()
							if lowerName:find("boss") or lowerName:find("king") or lowerName:find("beast") or lowerName:find("lord") then
								if dist < shortestBoss then
									shortestBoss = dist
									nearestBoss = v
								end
							else
								if dist < shortestEnemy then
									shortestEnemy = dist
									nearestEnemy = v
								end
							end
						end
					end
				end
			end
		end
	end

	return nearestBoss or nearestEnemy
end

-- üåÄ Tween m∆∞·ª£t ƒë·∫øn sau NPC (ch·ªâ 1 l·∫ßn, kh√¥ng tween tr√°i ph·∫£i)
local function tweenToTarget(target)
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if not hum or not root then return end
	if not target then return end

	local _, targetRoot = getHumanoidAndRoot(target)
	if not targetRoot then return end

	-- V·ªã tr√≠ ph√≠a sau qu√°i
	local behindDir = -targetRoot.CFrame.LookVector
	local targetPos = targetRoot.Position + behindDir * teleportDistance + Vector3.new(0, hoverHeight, 0)

	-- T·∫°o tween di chuy·ªÉn th·∫≠t m∆∞·ª£t
	local dist = (root.Position - targetPos).Magnitude
	local duration = dist / tweenSpeed
	if duration < 0.1 then duration = 0.1 end

	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
	local tween = TweenService:Create(root, tweenInfo, { CFrame = CFrame.new(targetPos, targetRoot.Position) })
	tween:Play()
	tween.Completed:Wait()
end

-- üîÅ Auto Farm Loop
task.spawn(function()
	while task.wait(updateDelay) do
		if _G.AutoTween then
			local npc = getNearestNPC()
			if npc then
				local hum, hrp = getHumanoidAndRoot(npc)
				if hum and hrp and hum.Health > 0 then
					tweenToTarget(npc)
				end
			end
		end
	end
end)

-- ü™Ñ Toggle Auto Farm (Rayfield)
local ToggleFarm = Tab:CreateToggle({
	Name = "Auto Farm (Smooth Behind NPC)",
	CurrentValue = false,
	Flag = "ToggleAutoFarm",
	Callback = function(Value)
		_G.AutoTween = Value
		local char = LocalPlayer.Character
		if not char then return end
		local hum, root = getHumanoidAndRoot(char)
		if not hum or not root then return end

		if Value then
			hum.PlatformStand = true
			hum:ChangeState(Enum.HumanoidStateType.Physics)
			warn("[AUTO-FARM] ‚úÖ ƒê√£ b·∫≠t: Di chuy·ªÉn m∆∞·ª£t ph√≠a sau qu√°i (∆∞u ti√™n Boss).")
		else
			hum.PlatformStand = false
			hum:ChangeState(Enum.HumanoidStateType.GettingUp)
			warn("[AUTO-FARM] ‚õî ƒê√£ t·∫Øt.")
		end
	end
})




local Toggle = MiscTab:CreateToggle({
	Name = "Auto Start",
	CurrentValue = false,
	Flag = "Toggle_AutoStart",
	Callback = function(Value)
		_G.AutoStart = Value

		if _G.AutoStart then
			warn("‚úÖ Auto Start ƒê√É B·∫¨T")

			-- üîÅ Ch·∫°y li√™n t·ª•c cho ƒë·∫øn khi t·∫Øt
			task.spawn(function()
            repeat task.wait() until _G.ComboDone == true

				while _G.AutoStart do
					-- ‚ö° G·ª≠i l·ªánh start
					game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer()
					warn("üîÅ Auto Start ƒëang th·ª±c thi...")

					-- ‚è± Ch·ªù 1‚Äì2 gi√¢y ƒë·ªÉ tr√°nh spam server
					task.wait(2)
				end
				warn("‚õî Auto Start ƒê√É D·ª™NG")
			end)

		else
			warn("‚õî Auto Start ƒê√É T·∫ÆT TH·ª¶ C√îNG")
		end
	end,
})


--// üß© Auto Bonus Boss
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local dataRemoteEvent = ReplicatedStorage:WaitForChild("dataRemoteEvent")

_G.AutoBonusBoss = false

local AutoBonus = MiscTab:CreateToggle({
    Name = "Auto Bonus Boss",
    CurrentValue = false,
    Flag = "AutoBonusBoss",
    Callback = function(Value)
        _G.AutoBonusBoss = Value
        if Value then
            task.spawn(function()
                while _G.AutoBonusBoss do
                    task.wait(1)
                    local bonusAvailable = false

                    -- Ki·ªÉm tra n·∫øu server c√≥ th·ªÉ vote "bonus"
                    for _, remote in pairs(ReplicatedStorage:GetChildren()) do
                        if remote.Name == "dataRemoteEvent" then
                            bonusAvailable = true
                            break
                        end
                    end

                    -- N·∫øu c√≥ bonus ‚Üí vote bonus
                    if bonusAvailable then
                        dataRemoteEvent:FireServer({
                            {
                                ["\3"] = "vote",
                                vote = "bonus"
                            },
                            "-"
                        })
                        task.wait(1) -- ch·ªù x√≠u ƒë·ªÉ bonus x·ª≠ l√Ω xong
                    end
                end
            end)
        end
    end,
})

--// ‚öôÔ∏è T√≠ch h·ª£p ∆∞u ti√™n AutoBonusBoss tr∆∞·ªõc AutoRetry
-- Gi·∫£ s·ª≠ AutoRetry c√≥ bi·∫øn _G.AutoRetry
task.spawn(function()
    while task.wait(1) do
        if _G.AutoRetry then
            if _G.AutoBonusBoss then
                -- N·∫øu bonus c√≥ s·∫µn th√¨ ∆∞u ti√™n vote tr∆∞·ªõc khi retry
                local bonusAvailable = false
                for _, remote in pairs(ReplicatedStorage:GetChildren()) do
                    if remote.Name == "dataRemoteEvent" then
                        bonusAvailable = true
                        break
                    end
                end

                if bonusAvailable then
                    dataRemoteEvent:FireServer({
                        {
                            ["\3"] = "vote",
                            vote = "bonus"
                        },
                        "-"
                    })
                    task.wait(1.5) -- ƒê·ª£i x·ª≠ l√Ω bonus
                end
            end

            -- Ti·∫øp t·ª•c auto retry b√¨nh th∆∞·ªùng
            pcall(function()
                local retryRemote = ReplicatedStorage:FindFirstChild("retryRemoteEvent") or ReplicatedStorage:FindFirstChild("Retry")
                if retryRemote then
                    retryRemote:FireServer()
                end
            end)
        end
    end
end)



local Toggle = MiscTab:CreateToggle({
	Name = "Auto Retry",
	CurrentValue = false,
	Flag = "Toggle_AutoRetry",
	Callback = function(Value)
		_G.AutoRetry = Value

		if _G.AutoRetry then
			warn("‚úÖ Auto Retry ƒê√É B·∫¨T")

			-- üîÅ Ch·∫°y li√™n t·ª•c cho ƒë·∫øn khi t·∫Øt
			task.spawn(function()
				while _G.AutoRetry do
					-- ‚ö° G·ª≠i l·ªánh retry
					local args = {
                        [1] = {
                            [1] = {
                                ["\3"] = "vote",
                                ["vote"] = true
                            },
                            [2] = "-"
                        }
                    }

                    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
					warn("üîÅ Auto Retry ƒëang th·ª±c thi...")

					-- ‚è± Ch·ªù 1‚Äì2 gi√¢y ƒë·ªÉ tr√°nh spam server
					task.wait(2)
				end
				warn("‚õî Auto Retry ƒê√É D·ª™NG")
			end)

		else
			warn("‚õî Auto Retry ƒê√É T·∫ÆT TH·ª¶ C√îNG")
		end
	end,
})

---- ‚öôÔ∏è FIX LAG (T√≠ch h·ª£p v√†o Misc Tab)
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local active = false
local saved = {}

-- üåà L∆∞u c·∫•u h√¨nh √°nh s√°ng g·ªëc
local function saveOriginal()
    saved.Lighting = {
        Technology = Lighting.Technology,
        GlobalShadows = Lighting.GlobalShadows,
        Brightness = Lighting.Brightness,
        FogEnd = Lighting.FogEnd
    }
end

-- üîÑ Kh√¥i ph·ª•c c·∫•u h√¨nh √°nh s√°ng g·ªëc
local function restoreOriginal()
    if not saved.Lighting then return end
    Lighting.Technology = saved.Lighting.Technology
    Lighting.GlobalShadows = saved.Lighting.GlobalShadows
    Lighting.Brightness = saved.Lighting.Brightness
    Lighting.FogEnd = saved.Lighting.FogEnd
end

-- üí® H√†m gi·∫£m hi·ªáu ·ª©ng t·ª´ng ƒë·ªëi t∆∞·ª£ng
local function minimize(obj)
    if obj:IsA("ParticleEmitter") or obj:IsA("Beam") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
        obj.Enabled = false
    end

    if obj:IsA("Explosion") then
        obj.Visible = false
    end

    if obj:IsA("BasePart") then
        obj.Material = Enum.Material.SmoothPlastic
        obj.Reflectance = 0
        obj.CastShadow = false
        obj.Color = Color3.fromRGB(200,200,200)
    end

    if obj:IsA("Decal") or obj:IsA("Texture") then
        obj.Transparency = 1
    end

    if obj:IsA("Sound") then
        obj.Volume = 0
        obj:Stop()
    end

    if obj:IsA("Light") then
        obj.Enabled = false
    end
end

-- üöÄ √Åp d·ª•ng ch·∫ø ƒë·ªô gi·∫£m lag
local function applyLiteMode()
    Lighting.Technology = Enum.Technology.Compatibility
    Lighting.GlobalShadows = false
    Lighting.Brightness = 1
    Lighting.FogEnd = 999999999

    for _, obj in ipairs(Workspace:GetDescendants()) do
        minimize(obj)
    end

    Workspace.DescendantAdded:Connect(function(obj)
        if active then minimize(obj) end
    end)
end

-- üß© B·∫≠t/T·∫Øt FixLag
local function toggleFixLag(on)
    active = on
    if on then
        saveOriginal()
        applyLiteMode()
        warn("‚úÖ Fix Lag LITE: ON")
    else
        restoreOriginal()
        warn("‚õî Fix Lag LITE: OFF (b·∫°n c√≥ th·ªÉ c·∫ßn rejoin ƒë·ªÉ kh√¥i ph·ª•c ho√†n to√†n)")
    end
end

-- üéõÔ∏è Th√™m Toggle v√†o Misc Tab
local ToggleFixLag = MiscTab:CreateToggle({
    Name = "Fix Lag (Lite Mode)",
    CurrentValue = false,
    Flag = "Toggle_FixLag",
    Callback = function(Value)
        toggleFixLag(Value)
    end,
})





local WalkspeedInput = MiscTab:CreateInput({
    Name = "Walkspeed Input",
    PlaceholderText = "Nh·∫≠p t·ªëc ƒë·ªô (VD: 100)",
    CurrentValue = "16",
    RemoveTextAfterFocusLost = false,
    Flag = "Walkspeed_Input",

    Callback = function(Text)
        local Speed = tonumber(Text)
        if not Speed then
            warn("‚ùå H√£y nh·∫≠p s·ªë h·ª£p l·ªá!")
            return
        end

        Speed = math.clamp(Speed, 0, 300)

        local player = game.Players.LocalPlayer
        local humanoid = player and player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = Speed
            warn("‚úÖ ƒê·∫∑t t·ªëc ƒë·ªô th√†nh:", Speed)
        end
    end,
})

-- üß† Th√™m s·ª± ki·ªán auto-clear khi click v√†o textbox
task.spawn(function()
    task.wait(1) -- ƒë·ª£i UI load xong
    local box = WalkspeedInput.InputBox or WalkspeedInput.TextBox or WalkspeedInput

    if box and box.FocusGained then
        box.FocusGained:Connect(function()
            box.Text = "" -- xo√° n·ªôi dung hi·ªán t·∫°i khi click v√†o
        end)
    else
        warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y TextBox (c√≥ th·ªÉ UI lib c·ªßa b·∫°n d√πng t√™n kh√°c)")
    end
end)

-- üß† T·ª± ƒë·ªông kh√¥i ph·ª•c l·∫°i tr·∫°ng th√°i Toggle/Input khi m·ªü l·∫°i game
task.spawn(function()
    task.wait(1) -- ƒë·ª£i UI load ho√†n t·∫•t
    Rayfield.LoadConfiguration() -- kh√¥i ph·ª•c m·ªçi gi√° tr·ªã ƒë√£ l∆∞u
end)
