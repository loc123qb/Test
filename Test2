local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/Puhcoder16/theme/refs/heads/main/theme"))()
    local Window = Rayfield:CreateWindow({
   Name = "Loc dep trai",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Ez",
   LoadingSubtitle = "by Locc",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "M", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
   Enabled = true,
   FolderName = "Loccdz", -- üëà ph·∫£i ƒë·ªÉ trong d·∫•u ngo·∫∑c k√©p
   FileName = "Locc Hub"
},

        
   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local Tab = Window:CreateTab("Home", nil) -- Title, Image
local MainSection = Tab:CreateSection("Main")
local MiscTab = Window:CreateTab("Misc", nil) -- Title, Image

-- Bi·∫øn to√†n c·ª•c ƒëi·ªÅu khi·ªÉn
_G.AutoSkill = false

-- T·∫°o toggle Auto Skill
local Toggle = Tab:CreateToggle({
    Name = "Auto Skill Chain Lightning",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        _G.AutoSkill = Value
        if Value then
            print("ƒê√£ b·∫≠t Auto Skill")
            AutoSkillFunc()
        else
            print("ƒê√£ t·∫Øt Auto Skill")
        end
    end,
})

-- Auto Skill: Chain Lightning (ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu)
function AutoSkillFunc()
    task.spawn(function()
        -- N·∫øu bi·∫øn _G.ComboDone ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (kh√¥ng d√πng combo), m·∫∑c ƒë·ªãnh cho true
        if _G.ComboDone == nil then _G.ComboDone = true end

        -- Ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu (n·∫øu combo ƒëang ch·∫°y)
        repeat task.wait() until _G.ComboDone == true

        -- B·∫Øt ƒë·∫ßu loop s·ª≠ d·ª•ng skill khi _G.AutoSkill = true
        while _G.AutoSkill do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "EBD5165C-DB2C-4A41-A43C-7EC83AEB89E9" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Chain Lightning")) 
                              or (player.Character and player.Character:FindFirstChild("Chain Lightning"))
                if skill and skill:FindFirstChild("abilityEvent") then
                    skill.abilityEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoSkill] pcall error:", err)
                task.wait(0.5)
            end
        end
    end)
end


-- Bi·∫øn ƒëi·ªÅu khi·ªÉn AutoLift
_G.Autolift = false
local running = false

-- Auto Heal: Chain Heal (ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu)
local function AutoLiftFunc()
    if running then return end -- tr√°nh ch·∫°y tr√πng
    running = true
    task.spawn(function()
        -- N·∫øu bi·∫øn _G.ComboDone ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (kh√¥ng d√πng combo), m·∫∑c ƒë·ªãnh cho true
        if _G.ComboDone == nil then _G.ComboDone = true end

        -- Ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu (n·∫øu combo ƒëang ch·∫°y)
        repeat task.wait() until _G.ComboDone == true

        while _G.Autolift do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "852E0487-29F7-4293-AD32-9F02DD884A51" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Chain Heal"))
                              or (player.Character and player.Character:FindFirstChild("Chain Heal"))
                if skill and skill:FindFirstChild("spellEvent") then
                    skill.spellEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoHeal] pcall error:", err)
                task.wait(0.5)
            end
        end

        running = false
    end)
end


-- T·∫°o Toggle tr√™n GUI
local Toggle = Tab:CreateToggle({
    Name = "Auto Heal (Chain Heal)",
    CurrentValue = false,      -- m·∫∑c ƒë·ªãnh t·∫Øt
    Flag = "Toggle_AutoHeal",  -- Flag duy nh·∫•t ƒë·ªÉ l∆∞u
    Callback = function(Value)
        _G.Autolift = Value
        if Value then
            print("‚úÖ Auto Heal ƒê√É B·∫¨T")
            AutoLiftFunc()
        else
            print("‚õî Auto Heal ƒê√É T·∫ÆT")
        end
    end,
})


--// ‚ö° Auto Overcharge (theo phong c√°ch Auto Heal)
_G.AutoOvercharge = false
local running = false

-- H√†m ch√≠nh
local function AutoOverchargeFunc()
    if running then return end -- tr√°nh ch·∫°y tr√πng
    running = true
    task.spawn(function()
        -- N·∫øu c√≥ combo th√¨ ch·ªù ho√†n t·∫•t tr∆∞·ªõc khi k√≠ch ho·∫°t
        if _G.ComboDone == nil then _G.ComboDone = true end
        repeat task.wait() until _G.ComboDone == true

        while _G.AutoOvercharge do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "17314bb0-099c-461b-afb9-01ddcad548bd" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Overcharge"))
                            or (player.Character and player.Character:FindFirstChild("Overcharge"))
                if skill and skill:FindFirstChild("abilityEvent") then
                    skill.abilityEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoOvercharge] pcall error:", err)
                task.wait(0.5)
            end
        end

        running = false
    end)
end

--// üß© Toggle tr√™n GUI
local Toggle = Tab:CreateToggle({
    Name = "Auto Overcharge",
    CurrentValue = false,          -- m·∫∑c ƒë·ªãnh t·∫Øt
    Flag = "Toggle_AutoOvercharge", -- Flag duy nh·∫•t ƒë·ªÉ l∆∞u
    Callback = function(Value)
        _G.AutoOvercharge = Value
        if Value then
            print("‚úÖ Auto Overcharge ƒê√É B·∫¨T")
            AutoOverchargeFunc()
        else
            print("‚õî Auto Overcharge ƒê√É T·∫ÆT")
        end
    end,
})


-- ========= Auto Combo (1 l·∫ßn) + Toggle (l∆∞u config) =========
-- Ch√®n sau Auto Heal toggle, tr∆∞·ªõc Auto Farm

-- ƒë·∫£m b·∫£o bi·∫øn to√†n c·ª•c t·ªìn t·∫°i
_G.ComboDone = _G.ComboDone or true
_G.ComboRunning = _G.ComboRunning or false

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- an to√†n: swap set
local function swapSet(setName)
    local args = {
        [1] = {
            [1] = { ["\3"] = "swapAbilitySet" },
            [2] = setName
        }
    }
    if ReplicatedStorage:FindFirstChild("dataRemoteEvent") and type(ReplicatedStorage.dataRemoteEvent.FireServer) == "function" then
        pcall(function()
            ReplicatedStorage.dataRemoteEvent:FireServer(unpack(args))
        end)
    end
end

-- an to√†n: d√πng skill (t√¨m trong Backpack ho·∫∑c Character)
local function useSkill(skillName, skillID)
    if not player then return false end

    local function findInst(name)
        if player:FindFirstChild("Backpack") then
            local s = player.Backpack:FindFirstChild(name)
            if s then return s end
        end
        if player.Character then
            local s2 = player.Character:FindFirstChild(name)
            if s2 then return s2 end
        end
        -- fallback: t√¨m theo descendants (n·∫øu t√™n n·∫±m s√¢u)
        if player:FindFirstChild("Backpack") then
            for _,v in ipairs(player.Backpack:GetDescendants()) do
                if v.Name == name then return v end
            end
        end
        if player.Character then
            for _,v in ipairs(player.Character:GetDescendants()) do
                if v.Name == name then return v end
            end
        end
        return nil
    end

    local inst = findInst(skillName)
    if not inst then return false end

    local ev = inst:FindFirstChild("abilityEvent") or inst:FindFirstChild("spellEvent")
    if ev and type(ev.FireServer) == "function" then
        pcall(function() ev:FireServer(skillID) end)
        return true
    end

    -- n·∫øu instance b·∫£n th√¢n c√≥ FireServer (hi·∫øm)
    if type(inst.FireServer) == "function" then
        pcall(function() inst:FireServer(skillID) end)
        return true
    end

    return false
end

-- ch·∫°y combo 1 l·∫ßn, ƒë·∫∑t _G.ComboDone = true ch·ªâ khi ho√†n t·∫•t th·∫≠t s·ª±
local function RunComboOnce()
    if _G.ComboRunning then return end
    _G.ComboRunning = true
    _G.ComboDone = false -- kho√° c√°c script kh√°c

    task.spawn(function()
        local setM, setN = "M", "N"

        -- 1) ƒë·ªïi sang M
        swapSet(setM)
        task.wait(0.4) -- ƒë·ª£i swap server sync

        -- 2) d√πng Inner Focus
        local ok1 = useSkill("Inner Focus", "6D6A8BC4-B85F-4A20-B626-8AF8EF44DB9D")
        if not ok1 then warn("[AutoCombo] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ d√πng Inner Focus") end

        -- 3) ch·ªù 1s -> d√πng Innervate
        task.wait(1)
        local ok2 = useSkill("Innervate", "87C934DD-13DE-4DD2-A8BC-B3DA8C470515")
        if not ok2 then warn("[AutoCombo] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ d√πng Innervate") end

        -- 4) ch·ªù 1s -> swap set M 1 l·∫ßn n·ªØa
        task.wait(1)
        swapSet(setM)
        task.wait(0.5)

        -- 5) swap v·ªÅ set N (ban ƒë·∫ßu)
        swapSet(setN)
        task.wait(0.2)

        -- ho√†n t·∫•t
        _G.ComboDone = true
        _G.ComboRunning = false

        if Rayfield and type(Rayfield.Notify) == "function" then
            pcall(function()
                Rayfield:Notify({
                    Title = "Auto Combo",
                    Content = "Combo ho√†n t·∫•t ‚Äî scripts kh√°c s·∫Ω b·∫Øt ƒë·∫ßu.",
                    Duration = 3
                })
            end)
        else
            print("[AutoCombo] Combo ho√†n t·∫•t")
        end
    end)
end

-- Toggle (l∆∞u config b·∫±ng Flag)
local AutoComboToggle = Tab:CreateToggle({
    Name = "Auto Combo 1 L·∫ßn (Save Config)",
    CurrentValue = false,
    Flag = "AutoComboOnce",
    Callback = function(Value)
        if Value then
            -- khi b·∫≠t toggle: ch·∫°y 1 l·∫ßn
            RunComboOnce()
        end
    end,
})

-- Khi load script n·∫øu Flag ƒë√£ b·∫≠t (ƒë∆∞·ª£c l∆∞u) -> t·ª± ch·∫°y 1 l·∫ßn
task.defer(function()
    task.wait(1)
    if Rayfield and Rayfield.Flags and Rayfield.Flags.AutoComboOnce and Rayfield.Flags.AutoComboOnce.CurrentValue == true then
        -- n·∫øu combo ch∆∞a ch·∫°y th√¨ ch·∫°y 1 l·∫ßn
        if not _G.ComboRunning and _G.ComboDone ~= true then
            RunComboOnce()
        elseif not _G.ComboRunning and _G.ComboDone == true then
            -- n·∫øu ComboDone ƒë√£ true (kh√¥ng c·∫ßn ch·∫°y), ƒë·∫£m b·∫£o combo tr·∫°ng th√°i OK
        else
            -- ƒëang ch·∫°y, ƒë·ª£i xong
        end
    end
end)
-- ========= END =========


--// üåä Auto Farm Hover Tween - Smooth Circle + Auto Dodge Zone (AOE) - Optimized for Dungeon Quest
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- ‚öôÔ∏è C·∫•u h√¨nh
local tweenSpeed = 10
local hoverHeight = 0
local maxRange = 4000
local teleportDistance = 15
local teleportDelay = 1.25
local orbitRadius = 20
local orbitDuration = 3
local dodgeDistance = 20
local dodgeDetectRange = 30
local dodgeCooldown = 1.2

_G.AutoTween = false
_G.AutoDodgeZone = false
_G.ComboDone = _G.ComboDone or true -- ƒë·∫£m b·∫£o loop ho·∫°t ƒë·ªông n·∫øu kh√¥ng c√≥ combo

-- üß† H√†m h·ªó tr·ª£
local function getHumanoidAndRoot(model)
	if not model then return end
	local hum = model:FindFirstChildOfClass("Humanoid")
	local root = model:FindFirstChild("HumanoidRootPart")
	return hum, root
end

local function isPlayerModel(model)
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr.Character == model then
			return true
		end
	end
	return false
end

-- üßç Ki·ªÉm tra NPC ƒë√£ spawn ho√†n ch·ªânh (ƒë·ª©ng tr√™n m·∫∑t ƒë·∫•t)
local function isNPCReady(npc)
	local hum, hrp = getHumanoidAndRoot(npc)
	if not (hum and hrp) then return false end
	if hum.Health <= 0 then return false end

	-- Ki·ªÉm tra n·∫øu HRP ·ªü d∆∞·ªõi map ho·∫∑c ch∆∞a ch·∫°m ƒë·∫•t
	local ray = Ray.new(hrp.Position, Vector3.new(0, -10, 0))
	local hit = Workspace:FindPartOnRay(ray, npc)
	if not hit then return false end

	-- th√™m ki·ªÉm tra Y h·ª£p l√Ω
	if hrp.Position.Y < -50 then return false end

	return true
end

-- üîç T√¨m NPC h·ª£p l·ªá to√†n map Dungeon Quest (∆∞u ti√™n boss tr∆∞·ªõc)
local function getPriorityNPC()
	local char = LocalPlayer.Character
	if not char then return end
	local _, root = getHumanoidAndRoot(char)
	if not root then return end

	-- folder kh·∫£ d·ª•ng - bao ph·ªß nhi·ªÅu map
	local possibleFolders = {
		"Enemies","Mobs","Live","Boss","Bosses","Dungeon","Hostiles","Monsters","ActiveEnemies","ActiveBosses"
	}

	-- gom c√°c Model t·ª´ c√°c folder n·∫øu c√≥
	local allNPCs = {}
	for _, name in ipairs(possibleFolders) do
		local folder = Workspace:FindFirstChild(name)
		if folder and (folder:IsA("Folder") or folder:IsA("Model")) then
			for _, v in ipairs(folder:GetDescendants()) do
				if v:IsA("Model") then
					allNPCs[#allNPCs + 1] = v
				end
			end
		elseif Workspace:FindFirstChild("Dungeon") and Workspace.Dungeon:FindFirstChild(name) then
			local sub = Workspace.Dungeon[name]
			for _, v in ipairs(sub:GetDescendants()) do
				if v:IsA("Model") then
					allNPCs[#allNPCs + 1] = v
				end
			end
		end
	end

	-- fallback: n·∫øu ch∆∞a c√≥ g√¨, l·∫•y descendants to√†n workspace (√≠t ∆∞u ti√™n)
	if #allNPCs == 0 then
		for _, v in ipairs(Workspace:GetDescendants()) do
			if v:IsA("Model") then
				allNPCs[#allNPCs + 1] = v
			end
		end
	end

	local targetBoss, targetMini, targetNormal
	local farthestBoss, farthestMini, farthestNormal = 0, 0, 0

	for _, v in ipairs(allNPCs) do
		if v and v:IsA("Model") and v ~= char and not isPlayerModel(v) then
			local hum, hrp = getHumanoidAndRoot(v)
			if hum and hrp and hum.Health > 0 and isNPCReady(v) then
				local dist = (hrp.Position - root.Position).Magnitude
				if dist < maxRange then
					local n = (v.Name or ""):lower()

					-- ∆Øu ti√™n boss keywords (m·ªü r·ªông)
					if n:find("final") or n:find("boss") or n:find("guardian") or n:find("king") or n:find("demon") or n:find("overlord") then
						if dist > farthestBoss then
							farthestBoss = dist
							targetBoss = v
						end
					elseif n:find("mini") or n:find("elite") or n:find("champion") or n:find("ceremonial") then
						if dist > farthestMini then
							farthestMini = dist
							targetMini = v
						end
					else
						if dist > farthestNormal then
							farthestNormal = dist
							targetNormal = v
						end
					end
				end
			end
		end
	end

	return targetBoss or targetMini or targetNormal
end

-- üõ°Ô∏è H·ªó tr·ª£ reset an to√†n
local function safeResetToGround(root)
	if not root then return end
	local pos = root.Position
	if pos.Y < -20 then
		root.CFrame = CFrame.new(pos.X, 5, pos.Z)
		warn("[SAFE] Reset v·ªã tr√≠ an to√†n.")
	end
end

-- üåÄ Di chuy·ªÉn m∆∞·ª£t: s·ª≠ d·ª•ng fakeRoot + CFrame:Lerp ƒë·ªÉ tr√°nh spam CFrame
local lastTweenTime = 0
local function tweenTo(target)
	if not _G.AutoTween then return end
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if not root then return end
	if not target then return end

	local _, targetRoot = getHumanoidAndRoot(target)
	if not targetRoot then return end
	if not isNPCReady(target) then return end

	-- gi·ªõi h·∫°n t·∫ßn su·∫•t tween (ƒë·ª° spam)
	local minInterval = math.max(teleportDelay, 1.25)
	if tick() - lastTweenTime < minInterval then return end
	lastTweenTime = tick()

	-- ch·ªù 1.25s (ho·∫∑c teleportDelay) tr∆∞·ªõc khi di chuy·ªÉn (gi·ªØ an to√†n)
	task.wait(teleportDelay)

	-- t√≠nh v·ªã tr√≠ ph√≠a sau (safe)
	local behindDir = -targetRoot.CFrame.LookVector
	local desiredPos = targetRoot.Position + behindDir * teleportDistance + Vector3.new(0, hoverHeight, 0)

	-- ki·ªÉm tra v·ªã tr√≠ h·ª£p l·ªá
	if (desiredPos - root.Position).Magnitude > 2000 or desiredPos.Y < -50 or desiredPos.Y > 300 then
		-- b·∫•t th∆∞·ªùng -> abort
		return
	end

	-- t·∫°o fakeRoot anchored ƒë·ªÉ tween
	local fakeRoot = Instance.new("Part")
	fakeRoot.Size = Vector3.new(2,2,2)
	fakeRoot.Transparency = 1
	fakeRoot.CanCollide = false
	fakeRoot.Anchored = true
	fakeRoot.CFrame = root.CFrame
	fakeRoot.Parent = Workspace

	-- tween fakeRoot t·ªõi v·ªã tr√≠ mong mu·ªën (k√©o d√†i, m∆∞·ª£t)
	local tweenInfo = TweenInfo.new(1.4, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local t = TweenService:Create(fakeRoot, tweenInfo, { CFrame = CFrame.new(desiredPos, targetRoot.Position) })
	t:Play()

	-- c·∫≠p nh·∫≠t root m·ªói Heartbeat b·∫±ng Lerp (gi·∫£m gi·∫≠t, tr√°nh b·ªã kick)
	local conn
	conn = RunService.Heartbeat:Connect(function()
		if not _G.AutoTween then
			conn:Disconnect()
			return
		end
		if not fakeRoot or not fakeRoot.Parent then
			conn:Disconnect()
			return
		end
		-- Lerp CFrame ƒë·ªÉ m∆∞·ª£t, alpha nh·ªè tr√°nh nh·∫£y
		local cur = root.CFrame
		local goal = fakeRoot.CFrame
		root.CFrame = cur:Lerp(goal, 0.35) -- 0.35 l√† t·ªëc ƒë·ªô b·∫Øt k·ªãp, nh·ªè h∆°n => m∆∞·ª£t h∆°n
		-- ƒë·∫£m b·∫£o kh√¥ng r∆°i nhanh
		safeResetToGround(root)
	end)

	t.Completed:Wait()
	if conn and conn.Connected then conn:Disconnect() end

	-- sau khi tween xong: neo an to√†n ph√≠a sau boss
	local function keepBehindLoop()
		local keepConn
		keepConn = RunService.Heartbeat:Connect(function()
			if not _G.AutoTween then
				keepConn:Disconnect()
				if fakeRoot and fakeRoot.Parent then fakeRoot:Destroy() end
				return
			end
			if not (target and target.Parent) then
				keepConn:Disconnect()
				if fakeRoot and fakeRoot.Parent then fakeRoot:Destroy() end
				return
			end
			local _, tRoot = getHumanoidAndRoot(target)
			if not tRoot then
				keepConn:Disconnect()
				if fakeRoot and fakeRoot.Parent then fakeRoot:Destroy() end
				return
			end

			local behind = -tRoot.CFrame.LookVector
			local stayPos = tRoot.Position + behind * teleportDistance + Vector3.new(0, hoverHeight, 0)

			-- ch·ªâ ƒëi·ªÅu ch·ªânh nh·∫π n·∫øu h∆∞·ªõng boss ƒë·ªïi nhanh (tr√°nh teleport m·∫°nh)
			local diff = (stayPos - root.Position).Magnitude
			if diff < 60 then
				local cur = root.CFrame
				root.CFrame = cur:Lerp(CFrame.new(stayPos, tRoot.Position), 0.35)
			else
				-- n·∫øu boss d·ªãch chuy·ªÉn qu√° xa, kh√¥ng √©p theo ƒë·ªÉ tr√°nh b·ªã kick; s·∫Ω ch·ªù l·∫ßn tween ti·∫øp theo
			end

			-- reset n·∫øu r∆°i
			safeResetToGround(root)
		end)
		-- d·ª´ng sau khi _G.AutoTween = false ho·∫∑c target bi·∫øn m·∫•t
		-- keepConn t·ª± d·ª´ng trong body tr√™n
	end

	keepBehindLoop()

	-- destroy fakeRoot sau 0.5s (n·∫øu c√≤n)
	task.delay(0.5, function()
		if fakeRoot and fakeRoot.Parent then fakeRoot:Destroy() end
	end)
end

-- üîé Ph√°t hi·ªán telegraph/zone m·ªõi trong workspace v√† tween ra sau qu√°i (auto dodge timing)
local activeZoneDodge = false
local detectedZones = setmetatable({}, {__mode = "k"})

local function isRedColor(c)
	if not c then return false end
	return (c.R > 0.4 and c.G < 0.3 and c.B < 0.3)
end

local function isDangerPart(part)
	if not part or not part:IsA("BasePart") then return false end
	local n = (part.Name or ""):lower()
	if n:find("zone") or n:find("aoe") or n:find("telegraph") or n:find("warning") or n:find("indicator") or n:find("attack") then
		return true
	end
	if isRedColor(part.Color) and part.Transparency < 0.7 then
		return true
	end
	-- shape/mesh heuristics: large flat parts on ground often telegraph
	if part.Size and (part.Size.X > 3 or part.Size.Z > 3) and part.Position.Y < 10 then
		-- additional check: name contains nothing but it's big and near ground -> possibly telegraph
		return true
	end
	return false
end

local function moveBehindNPCOfPart(part)
	if not _G.AutoTween then return end
	if activeZoneDodge then return end
	activeZoneDodge = true

	-- t√¨m npc g·∫ßn part nh·∫•t (trong folder NPC)
	local nearestNPC = nil
	local nearestDist = 1e9
	-- use getPriorityNPC list scan folders quickly
	local possibleFolders = {"Enemies","Mobs","Live","Boss","Bosses","Dungeon","Hostiles","Monsters","ActiveEnemies","ActiveBosses"}
	local candidates = {}
	for _, name in ipairs(possibleFolders) do
		local folder = Workspace:FindFirstChild(name)
		if folder then
			for _, c in ipairs(folder:GetChildren()) do
				if c:IsA("Model") then candidates[#candidates+1] = c end
			end
		end
	end
	if #candidates == 0 then
		for _, c in ipairs(Workspace:GetDescendants()) do
			if c:IsA("Model") then candidates[#candidates+1] = c end
		end
	end

	for _, cand in ipairs(candidates) do
		local hum, hrp = getHumanoidAndRoot(cand)
		if hum and hrp and hum.Health > 0 then
			local dist = (hrp.Position - part.Position).Magnitude
			if dist < nearestDist then
				nearestDist = dist
				nearestNPC = cand
			end
		end
	end

	-- n·∫øu g·∫ßn NPC trong kho·∫£ng h·ª£p l√Ω th√¨ tween ra sau n√≥
	if nearestNPC and nearestDist < 120 then
		-- tween ra ph√≠a sau nearestNPC
		local _, npcRoot = getHumanoidAndRoot(nearestNPC)
		if npcRoot then
			local char = LocalPlayer.Character
			if not char then activeZoneDodge = false return end
			local hum, root = getHumanoidAndRoot(char)
			if not root then activeZoneDodge = false return end

			local behindDir = -npcRoot.CFrame.LookVector
			local dodgePos = root.Position + behindDir * dodgeDistance + Vector3.new(0, 2, 0)
			-- clamp dodgePos to ground
			local ray = Ray.new(dodgePos + Vector3.new(0,5,0), Vector3.new(0,-50,0))
			local hit, hitpos = Workspace:FindPartOnRay(ray)
			if hit and hitpos then dodgePos = Vector3.new(dodgePos.X, hitpos.Y + 1.5, dodgePos.Z) end

			-- Tween nh·∫π nh√†ng
			local tweenInfo = TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local tw = TweenService:Create(root, tweenInfo, {CFrame = CFrame.new(dodgePos)})
			tw:Play()
			tw.Completed:Wait()
		end
	end

	-- cooldown nh·ªè tr∆∞·ªõc khi cho ph√©p dodge ti·∫øp
	task.delay(0.6, function() activeZoneDodge = false end)
end

-- l·∫Øng nghe th√™m part m·ªõi (k·ªπ nƒÉng telegraph/zone)
Workspace.DescendantAdded:Connect(function(obj)
	-- small guard
	if not obj or not obj:IsA("BasePart") then return end
	-- detect quickly
	if isDangerPart(obj) then
		-- tr√°nh duplicate
		if detectedZones[obj] then return end
		detectedZones[obj] = true
		task.defer(function()
			-- n·∫øu auto dodge zone t·∫Øt th√¨ th√¥i
			if not _G.AutoDodgeZone then return end
			-- n·∫øu player ·ªü qu√° xa th√¨ ignore
			local char = LocalPlayer.Character
			if not char then return end
			local _, root = getHumanoidAndRoot(char)
			if not root then return end
			local dist = (obj.Position - root.Position).Magnitude
			if dist > 120 then return end
			-- move behind relevant NPC
			moveBehindNPCOfPart(obj)
		end)
	end
end)

-- ‚ö° Auto Dodge Zone (fallback scan, d·ª± ph√≤ng)
local lastDodge = 0
local isDodging = false
local function autoDodgeZone()
	if not _G.AutoDodgeZone or isDodging then return end
	if tick() - lastDodge < dodgeCooldown then return end

	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if not root then return end

	-- scan existing large parts that look dangerous
	for _, v in ipairs(Workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Parent and not isPlayerModel(v.Parent) and isDangerPart(v) then
			local dist = (v.Position - root.Position).Magnitude
			if dist < dodgeDetectRange then
				isDodging = true
				lastDodge = tick()
				-- try move behind that part's nearest NPC
				moveBehindNPCOfPart(v)
				isDodging = false
				break
			end
		end
	end
end

-- üîÅ Auto Farm Loop
task.spawn(function()
	repeat task.wait() until _G.ComboDone == true
	while task.wait(0.25) do
		if _G.AutoTween then
			-- auto dodge via listener/fallback
			autoDodgeZone()
			local npc = getPriorityNPC()
			if npc then
				tweenTo(npc)
			end
		end
	end
end)

-- ü™Ñ Rayfield Toggle (th√™m v√†o Tab "Home")
local ToggleFarm = Tab:CreateToggle({
	Name = "Auto Farm (∆Øu ti√™n Boss)",
	CurrentValue = false,
	Flag = "ToggleAutoFarm",
	Callback = function(Value)
		_G.AutoTween = Value
		local char = LocalPlayer.Character
		if not char then return end
		local hum, root = getHumanoidAndRoot(char)
		if not hum or not root then return end

		if Value then
			hum.PlatformStand = true
			hum:ChangeState(Enum.HumanoidStateType.Physics)
			warn("[AUTO-FARM] ‚úÖ ƒê√£ b·∫≠t: ∆Øu ti√™n Boss, tween m∆∞·ª£t v√† an to√†n.")
		else
			hum.PlatformStand = false
			hum:ChangeState(Enum.HumanoidStateType.GettingUp)
			warn("[AUTO-FARM] ‚õî ƒê√£ t·∫Øt.")
		end
	end
})

local ToggleDodge = Tab:CreateToggle({
	Name = "Auto Dodge Zone (AOE)",
	CurrentValue = false,
	Flag = "ToggleAutoDodgeZone",
	Callback = function(Value)
		_G.AutoDodgeZone = Value
		if Value then
			warn("[AUTO-DODGE] ‚úÖ ƒê√£ b·∫≠t: N√© v√πng ƒë·ªè (AOE).")
		else
			warn("[AUTO-DODGE] ‚õî ƒê√£ t·∫Øt.")
		end
	end
})



local Toggle = MiscTab:CreateToggle({
	Name = "Auto Start",
	CurrentValue = false,
	Flag = "Toggle_AutoStart",
	Callback = function(Value)
		_G.AutoStart = Value

		if _G.AutoStart then
			warn("‚úÖ Auto Start ƒê√É B·∫¨T")

			-- üîÅ Ch·∫°y li√™n t·ª•c cho ƒë·∫øn khi t·∫Øt
			task.spawn(function()
            repeat task.wait() until _G.ComboDone == true

				while _G.AutoStart do
					-- ‚ö° G·ª≠i l·ªánh start
					game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer()
					warn("üîÅ Auto Start ƒëang th·ª±c thi...")

					-- ‚è± Ch·ªù 1‚Äì2 gi√¢y ƒë·ªÉ tr√°nh spam server
					task.wait(2)
				end
				warn("‚õî Auto Start ƒê√É D·ª™NG")
			end)

		else
			warn("‚õî Auto Start ƒê√É T·∫ÆT TH·ª¶ C√îNG")
		end
	end,
})


--// üß© Auto Bonus Boss
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local dataRemoteEvent = ReplicatedStorage:WaitForChild("dataRemoteEvent")

_G.AutoBonusBoss = false

local AutoBonus = MiscTab:CreateToggle({
    Name = "Auto Bonus Boss",
    CurrentValue = false,
    Flag = "AutoBonusBoss",
    Callback = function(Value)
        _G.AutoBonusBoss = Value
        if Value then
            task.spawn(function()
                while _G.AutoBonusBoss do
                    task.wait(1)
                    local bonusAvailable = false

                    -- Ki·ªÉm tra n·∫øu server c√≥ th·ªÉ vote "bonus"
                    for _, remote in pairs(ReplicatedStorage:GetChildren()) do
                        if remote.Name == "dataRemoteEvent" then
                            bonusAvailable = true
                            break
                        end
                    end

                    -- N·∫øu c√≥ bonus ‚Üí vote bonus
                    if bonusAvailable then
                        dataRemoteEvent:FireServer({
                            {
                                ["\3"] = "vote",
                                vote = "bonus"
                            },
                            "-"
                        })
                        task.wait(1) -- ch·ªù x√≠u ƒë·ªÉ bonus x·ª≠ l√Ω xong
                    end
                end
            end)
        end
    end,
})

--// ‚öôÔ∏è T√≠ch h·ª£p ∆∞u ti√™n AutoBonusBoss tr∆∞·ªõc AutoRetry
-- Gi·∫£ s·ª≠ AutoRetry c√≥ bi·∫øn _G.AutoRetry
task.spawn(function()
    while task.wait(1) do
        if _G.AutoRetry then
            if _G.AutoBonusBoss then
                -- N·∫øu bonus c√≥ s·∫µn th√¨ ∆∞u ti√™n vote tr∆∞·ªõc khi retry
                local bonusAvailable = false
                for _, remote in pairs(ReplicatedStorage:GetChildren()) do
                    if remote.Name == "dataRemoteEvent" then
                        bonusAvailable = true
                        break
                    end
                end

                if bonusAvailable then
                    dataRemoteEvent:FireServer({
                        {
                            ["\3"] = "vote",
                            vote = "bonus"
                        },
                        "-"
                    })
                    task.wait(1.5) -- ƒê·ª£i x·ª≠ l√Ω bonus
                end
            end

            -- Ti·∫øp t·ª•c auto retry b√¨nh th∆∞·ªùng
            pcall(function()
                local retryRemote = ReplicatedStorage:FindFirstChild("retryRemoteEvent") or ReplicatedStorage:FindFirstChild("Retry")
                if retryRemote then
                    retryRemote:FireServer()
                end
            end)
        end
    end
end)



local Toggle = MiscTab:CreateToggle({
	Name = "Auto Retry",
	CurrentValue = false,
	Flag = "Toggle_AutoRetry",
	Callback = function(Value)
		_G.AutoRetry = Value

		if _G.AutoRetry then
			warn("‚úÖ Auto Retry ƒê√É B·∫¨T")

			-- üîÅ Ch·∫°y li√™n t·ª•c cho ƒë·∫øn khi t·∫Øt
			task.spawn(function()
				while _G.AutoRetry do
					-- ‚ö° G·ª≠i l·ªánh retry
					local args = {
                        [1] = {
                            [1] = {
                                ["\3"] = "vote",
                                ["vote"] = true
                            },
                            [2] = "-"
                        }
                    }

                    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
					warn("üîÅ Auto Retry ƒëang th·ª±c thi...")

					-- ‚è± Ch·ªù 1‚Äì2 gi√¢y ƒë·ªÉ tr√°nh spam server
					task.wait(2)
				end
				warn("‚õî Auto Retry ƒê√É D·ª™NG")
			end)

		else
			warn("‚õî Auto Retry ƒê√É T·∫ÆT TH·ª¶ C√îNG")
		end
	end,
})

---- ‚öôÔ∏è FIX LAG (T√≠ch h·ª£p v√†o Misc Tab)
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local active = false
local saved = {}

-- üåà L∆∞u c·∫•u h√¨nh √°nh s√°ng g·ªëc
local function saveOriginal()
    saved.Lighting = {
        Technology = Lighting.Technology,
        GlobalShadows = Lighting.GlobalShadows,
        Brightness = Lighting.Brightness,
        FogEnd = Lighting.FogEnd
    }
end

-- üîÑ Kh√¥i ph·ª•c c·∫•u h√¨nh √°nh s√°ng g·ªëc
local function restoreOriginal()
    if not saved.Lighting then return end
    Lighting.Technology = saved.Lighting.Technology
    Lighting.GlobalShadows = saved.Lighting.GlobalShadows
    Lighting.Brightness = saved.Lighting.Brightness
    Lighting.FogEnd = saved.Lighting.FogEnd
end

-- üí® H√†m gi·∫£m hi·ªáu ·ª©ng t·ª´ng ƒë·ªëi t∆∞·ª£ng
local function minimize(obj)
    if obj:IsA("ParticleEmitter") or obj:IsA("Beam") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
        obj.Enabled = false
    end

    if obj:IsA("Explosion") then
        obj.Visible = false
    end

    if obj:IsA("BasePart") then
        obj.Material = Enum.Material.SmoothPlastic
        obj.Reflectance = 0
        obj.CastShadow = false
        obj.Color = Color3.fromRGB(200,200,200)
    end

    if obj:IsA("Decal") or obj:IsA("Texture") then
        obj.Transparency = 1
    end

    if obj:IsA("Sound") then
        obj.Volume = 0
        obj:Stop()
    end

    if obj:IsA("Light") then
        obj.Enabled = false
    end
end

-- üöÄ √Åp d·ª•ng ch·∫ø ƒë·ªô gi·∫£m lag
local function applyLiteMode()
    Lighting.Technology = Enum.Technology.Compatibility
    Lighting.GlobalShadows = false
    Lighting.Brightness = 1
    Lighting.FogEnd = 999999999

    for _, obj in ipairs(Workspace:GetDescendants()) do
        minimize(obj)
    end

    Workspace.DescendantAdded:Connect(function(obj)
        if active then minimize(obj) end
    end)
end

-- üß© B·∫≠t/T·∫Øt FixLag
local function toggleFixLag(on)
    active = on
    if on then
        saveOriginal()
        applyLiteMode()
        warn("‚úÖ Fix Lag LITE: ON")
    else
        restoreOriginal()
        warn("‚õî Fix Lag LITE: OFF (b·∫°n c√≥ th·ªÉ c·∫ßn rejoin ƒë·ªÉ kh√¥i ph·ª•c ho√†n to√†n)")
    end
end

-- üéõÔ∏è Th√™m Toggle v√†o Misc Tab
local ToggleFixLag = MiscTab:CreateToggle({
    Name = "Fix Lag (Lite Mode)",
    CurrentValue = false,
    Flag = "Toggle_FixLag",
    Callback = function(Value)
        toggleFixLag(Value)
    end,
})





local WalkspeedInput = MiscTab:CreateInput({
    Name = "Walkspeed Input",
    PlaceholderText = "Nh·∫≠p t·ªëc ƒë·ªô (VD: 100)",
    CurrentValue = "16",
    RemoveTextAfterFocusLost = false,
    Flag = "Walkspeed_Input",

    Callback = function(Text)
        local Speed = tonumber(Text)
        if not Speed then
            warn("‚ùå H√£y nh·∫≠p s·ªë h·ª£p l·ªá!")
            return
        end

        Speed = math.clamp(Speed, 0, 300)

        local player = game.Players.LocalPlayer
        local humanoid = player and player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = Speed
            warn("‚úÖ ƒê·∫∑t t·ªëc ƒë·ªô th√†nh:", Speed)
        end
    end,
})

-- üß† Th√™m s·ª± ki·ªán auto-clear khi click v√†o textbox
task.spawn(function()
    task.wait(1) -- ƒë·ª£i UI load xong
    local box = WalkspeedInput.InputBox or WalkspeedInput.TextBox or WalkspeedInput

    if box and box.FocusGained then
        box.FocusGained:Connect(function()
            box.Text = "" -- xo√° n·ªôi dung hi·ªán t·∫°i khi click v√†o
        end)
    else
        warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y TextBox (c√≥ th·ªÉ UI lib c·ªßa b·∫°n d√πng t√™n kh√°c)")
    end
end)

-- üß† T·ª± ƒë·ªông kh√¥i ph·ª•c l·∫°i tr·∫°ng th√°i Toggle/Input khi m·ªü l·∫°i game
task.spawn(function()
    task.wait(1) -- ƒë·ª£i UI load ho√†n t·∫•t
    Rayfield.LoadConfiguration() -- kh√¥i ph·ª•c m·ªçi gi√° tr·ªã ƒë√£ l∆∞u
end)
