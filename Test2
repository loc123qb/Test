local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/Puhcoder16/theme/refs/heads/main/theme"))()
    local Window = Rayfield:CreateWindow({
   Name = "Loc dep trai",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Ez",
   LoadingSubtitle = "by Locc",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "M", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
   Enabled = true,
   FolderName = "Loccdz", -- üëà ph·∫£i ƒë·ªÉ trong d·∫•u ngo·∫∑c k√©p
   FileName = "Locc Hub"
},

        
   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local Tab = Window:CreateTab("Home", nil) -- Title, Image
local MainSection = Tab:CreateSection("Main")
local MiscTab = Window:CreateTab("Misc", nil) -- Title, Image

-- Bi·∫øn to√†n c·ª•c ƒëi·ªÅu khi·ªÉn
_G.AutoSkill = false

-- T·∫°o toggle Auto Skill
local Toggle = Tab:CreateToggle({
    Name = "Auto Skill Chain Lightning",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        _G.AutoSkill = Value
        if Value then
            print("ƒê√£ b·∫≠t Auto Skill")
            AutoSkillFunc()
        else
            print("ƒê√£ t·∫Øt Auto Skill")
        end
    end,
})

-- Auto Skill: Chain Lightning (ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu)
function AutoSkillFunc()
    task.spawn(function()
        -- N·∫øu bi·∫øn _G.ComboDone ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (kh√¥ng d√πng combo), m·∫∑c ƒë·ªãnh cho true
        if _G.ComboDone == nil then _G.ComboDone = true end

        -- Ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu (n·∫øu combo ƒëang ch·∫°y)
        repeat task.wait() until _G.ComboDone == true

        -- B·∫Øt ƒë·∫ßu loop s·ª≠ d·ª•ng skill khi _G.AutoSkill = true
        while _G.AutoSkill do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "EBD5165C-DB2C-4A41-A43C-7EC83AEB89E9" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Chain Lightning")) 
                              or (player.Character and player.Character:FindFirstChild("Chain Lightning"))
                if skill and skill:FindFirstChild("abilityEvent") then
                    skill.abilityEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoSkill] pcall error:", err)
                task.wait(0.5)
            end
        end
    end)
end


-- Bi·∫øn ƒëi·ªÅu khi·ªÉn AutoLift
_G.Autolift = false
local running = false

-- Auto Heal: Chain Heal (ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu)
local function AutoLiftFunc()
    if running then return end -- tr√°nh ch·∫°y tr√πng
    running = true
    task.spawn(function()
        -- N·∫øu bi·∫øn _G.ComboDone ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (kh√¥ng d√πng combo), m·∫∑c ƒë·ªãnh cho true
        if _G.ComboDone == nil then _G.ComboDone = true end

        -- Ch·ªù combo ho√†n t·∫•t tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu (n·∫øu combo ƒëang ch·∫°y)
        repeat task.wait() until _G.ComboDone == true

        while _G.Autolift do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "852E0487-29F7-4293-AD32-9F02DD884A51" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Chain Heal"))
                              or (player.Character and player.Character:FindFirstChild("Chain Heal"))
                if skill and skill:FindFirstChild("spellEvent") then
                    skill.spellEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoHeal] pcall error:", err)
                task.wait(0.5)
            end
        end

        running = false
    end)
end


-- T·∫°o Toggle tr√™n GUI
local Toggle = Tab:CreateToggle({
    Name = "Auto Heal (Chain Heal)",
    CurrentValue = false,      -- m·∫∑c ƒë·ªãnh t·∫Øt
    Flag = "Toggle_AutoHeal",  -- Flag duy nh·∫•t ƒë·ªÉ l∆∞u
    Callback = function(Value)
        _G.Autolift = Value
        if Value then
            print("‚úÖ Auto Heal ƒê√É B·∫¨T")
            AutoLiftFunc()
        else
            print("‚õî Auto Heal ƒê√É T·∫ÆT")
        end
    end,
})


--// ‚ö° Auto Overcharge (theo phong c√°ch Auto Heal)
_G.AutoOvercharge = false
local running = false

-- H√†m ch√≠nh
local function AutoOverchargeFunc()
    if running then return end -- tr√°nh ch·∫°y tr√πng
    running = true
    task.spawn(function()
        -- N·∫øu c√≥ combo th√¨ ch·ªù ho√†n t·∫•t tr∆∞·ªõc khi k√≠ch ho·∫°t
        if _G.ComboDone == nil then _G.ComboDone = true end
        repeat task.wait() until _G.ComboDone == true

        while _G.AutoOvercharge do
            task.wait(0)
            local ok, err = pcall(function()
                local args = { [1] = "17314bb0-099c-461b-afb9-01ddcad548bd" }
                local player = game:GetService("Players").LocalPlayer
                local skill = (player and player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Overcharge"))
                            or (player.Character and player.Character:FindFirstChild("Overcharge"))
                if skill and skill:FindFirstChild("abilityEvent") then
                    skill.abilityEvent:FireServer(unpack(args))
                end
            end)
            if not ok then
                warn("[AutoOvercharge] pcall error:", err)
                task.wait(0.5)
            end
        end

        running = false
    end)
end

--// üß© Toggle tr√™n GUI
local Toggle = Tab:CreateToggle({
    Name = "Auto Overcharge",
    CurrentValue = false,          -- m·∫∑c ƒë·ªãnh t·∫Øt
    Flag = "Toggle_AutoOvercharge", -- Flag duy nh·∫•t ƒë·ªÉ l∆∞u
    Callback = function(Value)
        _G.AutoOvercharge = Value
        if Value then
            print("‚úÖ Auto Overcharge ƒê√É B·∫¨T")
            AutoOverchargeFunc()
        else
            print("‚õî Auto Overcharge ƒê√É T·∫ÆT")
        end
    end,
})


-- ========= Auto Combo (1 l·∫ßn) + Toggle (l∆∞u config) =========
-- Ch√®n sau Auto Heal toggle, tr∆∞·ªõc Auto Farm

-- ƒë·∫£m b·∫£o bi·∫øn to√†n c·ª•c t·ªìn t·∫°i
_G.ComboDone = _G.ComboDone or true
_G.ComboRunning = _G.ComboRunning or false

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- an to√†n: swap set
local function swapSet(setName)
    local args = {
        [1] = {
            [1] = { ["\3"] = "swapAbilitySet" },
            [2] = setName
        }
    }
    if ReplicatedStorage:FindFirstChild("dataRemoteEvent") and type(ReplicatedStorage.dataRemoteEvent.FireServer) == "function" then
        pcall(function()
            ReplicatedStorage.dataRemoteEvent:FireServer(unpack(args))
        end)
    end
end

-- an to√†n: d√πng skill (t√¨m trong Backpack ho·∫∑c Character)
local function useSkill(skillName, skillID)
    if not player then return false end

    local function findInst(name)
        if player:FindFirstChild("Backpack") then
            local s = player.Backpack:FindFirstChild(name)
            if s then return s end
        end
        if player.Character then
            local s2 = player.Character:FindFirstChild(name)
            if s2 then return s2 end
        end
        -- fallback: t√¨m theo descendants (n·∫øu t√™n n·∫±m s√¢u)
        if player:FindFirstChild("Backpack") then
            for _,v in ipairs(player.Backpack:GetDescendants()) do
                if v.Name == name then return v end
            end
        end
        if player.Character then
            for _,v in ipairs(player.Character:GetDescendants()) do
                if v.Name == name then return v end
            end
        end
        return nil
    end

    local inst = findInst(skillName)
    if not inst then return false end

    local ev = inst:FindFirstChild("abilityEvent") or inst:FindFirstChild("spellEvent")
    if ev and type(ev.FireServer) == "function" then
        pcall(function() ev:FireServer(skillID) end)
        return true
    end

    -- n·∫øu instance b·∫£n th√¢n c√≥ FireServer (hi·∫øm)
    if type(inst.FireServer) == "function" then
        pcall(function() inst:FireServer(skillID) end)
        return true
    end

    return false
end

-- ch·∫°y combo 1 l·∫ßn, ƒë·∫∑t _G.ComboDone = true ch·ªâ khi ho√†n t·∫•t th·∫≠t s·ª±
local function RunComboOnce()
    if _G.ComboRunning then return end
    _G.ComboRunning = true
    _G.ComboDone = false -- kho√° c√°c script kh√°c

    task.spawn(function()
        local setM, setN = "M", "N"

        -- 1) ƒë·ªïi sang M
        swapSet(setM)
        task.wait(0.4) -- ƒë·ª£i swap server sync

        -- 2) d√πng Inner Focus
        local ok1 = useSkill("Inner Focus", "6D6A8BC4-B85F-4A20-B626-8AF8EF44DB9D")
        if not ok1 then warn("[AutoCombo] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ d√πng Inner Focus") end

        -- 3) ch·ªù 1s -> d√πng Innervate
        task.wait(1)
        local ok2 = useSkill("Innervate", "87C934DD-13DE-4DD2-A8BC-B3DA8C470515")
        if not ok2 then warn("[AutoCombo] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ d√πng Innervate") end

        -- 4) ch·ªù 1s -> swap set M 1 l·∫ßn n·ªØa
        task.wait(1)
        swapSet(setM)
        task.wait(0.5)

        -- 5) swap v·ªÅ set N (ban ƒë·∫ßu)
        swapSet(setN)
        task.wait(0.2)

        -- ho√†n t·∫•t
        _G.ComboDone = true
        _G.ComboRunning = false

        if Rayfield and type(Rayfield.Notify) == "function" then
            pcall(function()
                Rayfield:Notify({
                    Title = "Auto Combo",
                    Content = "Combo ho√†n t·∫•t ‚Äî scripts kh√°c s·∫Ω b·∫Øt ƒë·∫ßu.",
                    Duration = 3
                })
            end)
        else
            print("[AutoCombo] Combo ho√†n t·∫•t")
        end
    end)
end

-- Toggle (l∆∞u config b·∫±ng Flag)
local AutoComboToggle = Tab:CreateToggle({
    Name = "Auto Combo 1 L·∫ßn (Save Config)",
    CurrentValue = false,
    Flag = "AutoComboOnce",
    Callback = function(Value)
        if Value then
            -- khi b·∫≠t toggle: ch·∫°y 1 l·∫ßn
            RunComboOnce()
        end
    end,
})

-- Khi load script n·∫øu Flag ƒë√£ b·∫≠t (ƒë∆∞·ª£c l∆∞u) -> t·ª± ch·∫°y 1 l·∫ßn
task.defer(function()
    task.wait(1)
    if Rayfield and Rayfield.Flags and Rayfield.Flags.AutoComboOnce and Rayfield.Flags.AutoComboOnce.CurrentValue == true then
        -- n·∫øu combo ch∆∞a ch·∫°y th√¨ ch·∫°y 1 l·∫ßn
        if not _G.ComboRunning and _G.ComboDone ~= true then
            RunComboOnce()
        elseif not _G.ComboRunning and _G.ComboDone == true then
            -- n·∫øu ComboDone ƒë√£ true (kh√¥ng c·∫ßn ch·∫°y), ƒë·∫£m b·∫£o combo tr·∫°ng th√°i OK
        else
            -- ƒëang ch·∫°y, ƒë·ª£i xong
        end
    end
end)
-- ========= END =========


--// üåä AUTO FARM DUNGEON QUEST - Hover Safe + Boss Priority + Full NPC Detection (Anti-kick tuned)
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- ‚öôÔ∏è C·∫•u h√¨nh (t√πy ch·ªânh n·∫øu c·∫ßn)
_G.AutoTween = false
local hoverHeight = 6                -- chi·ªÅu cao hover c·ªë ƒë·ªãnh so v·ªõi v·ªã tr√≠ NPC
local behindDistance = 8             -- ƒë·ª©ng sau NPC bao nhi√™u studs
local preTeleportDistance = 50       -- teleport t·ªõi g·∫ßn NPC (kho·∫£ng n√†y) tr∆∞·ªõc khi move nh·∫π v√†o
local avoidDistance = 20             -- kho·∫£ng c√°ch l√πi khi n√© skill
local updateDelay = 1.25             -- interval ch√≠nh
local maxRange = 4000                -- gi·ªõi h·∫°n t·∫ßm t√¨m NPC
local tweenStep = 8                  -- k√≠ch th∆∞·ªõc m·ªói b∆∞·ªõc tween (studs)
local tweenSpeed = 35                -- tham s·ªë ƒë·ªÉ t√≠nh th·ªùi gian tween cho m·ªói b∆∞·ªõc (s·ªë l·ªõn ‚Üí nhanh)
local reacting = false
local currentTarget = nil
local spawnPoint = nil

-- üß© H√†m h·ªó tr·ª£
local function getHumanoidAndRoot(model)
	if not model or not model:IsA("Model") then return end
	local hum = model:FindFirstChildOfClass("Humanoid")
	local root = model:FindFirstChild("HumanoidRootPart")
	if hum and root then return hum, root end
end

local function isPlayerModel(model)
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr.Character == model then
			return true
		end
	end
	return false
end

-- ki·ªÉm tra NPC ƒë√£ spawn ho√†n ch·ªânh (c√≥ Humanoid, HRP v√† ch·∫°m m·∫∑t ƒë·∫•t)
local function isNPCReady(npc)
	local hum, hrp = getHumanoidAndRoot(npc)
	if not hum or not hrp or hum.Health <= 0 then return false end
	local ray = Ray.new(hrp.Position, Vector3.new(0, -12, 0))
	local hit = Workspace:FindPartOnRay(ray, npc)
	return hit ~= nil
end

-- üîç T√¨m NPC g·∫ßn nh·∫•t, ∆∞u ti√™n boss (gi·ªØ backup t√¨m trong Enemies/Mobs n·∫øu c√≥)
local function getNearestTarget()
	local char = LocalPlayer.Character
	if not char then return end
	local _, root = getHumanoidAndRoot(char)
	if not root then return end

	local nearest, nearestDist = nil, math.huge
	local bossTarget, bossDist = nil, math.huge

	local function checkContainer(container)
		if not container then return end
		for _, v in ipairs(container:GetChildren()) do
			if v:IsA("Model") and not isPlayerModel(v) and v ~= char then
				local hum, hrp = getHumanoidAndRoot(v)
				if hum and hrp and hum.Health > 0 and isNPCReady(v) then
					local dist = (hrp.Position - root.Position).Magnitude
					if dist < maxRange then
						local n = v.Name:lower()
						-- ph√°t hi·ªán boss theo t√™n (c√≥ th·ªÉ b·ªï sung t·ª´ t·ª´ n·∫øu game d√πng t√™n kh√°c)
						if n:find("boss") or n:find("guardian") or n:find("king") or n:find("lord") or n:find("final") or n:find("beast") then
							if dist < bossDist then
								bossDist = dist
								bossTarget = v
							end
						elseif dist < nearestDist then
							nearestDist = dist
							nearest = v
						end
					end
				end
			end
		end
	end

	-- ∆∞u ti√™n c√°c folder ph·ªï bi·∫øn
	checkContainer(Workspace:FindFirstChild("Enemies"))
	checkContainer(Workspace:FindFirstChild("Mobs"))
	-- fallback: qu√©t to√†n workspace (√≠t t·ªën nh∆∞ng ch·ªâ l√†m khi ch∆∞a t√¨m ƒë∆∞·ª£c)
	if not bossTarget and not nearest then
		for _, v in ipairs(Workspace:GetDescendants()) do
			if v:IsA("Model") and not isPlayerModel(v) and v ~= char then
				local hum, hrp = getHumanoidAndRoot(v)
				if hum and hrp and hum.Health > 0 and isNPCReady(v) then
					local dist = (hrp.Position - root.Position).Magnitude
					if dist < maxRange then
						local n = v.Name:lower()
						if n:find("boss") or n:find("guardian") or n:find("king") then
							if dist < bossDist then
								bossDist = dist
								bossTarget = v
							end
						elseif dist < nearestDist then
							nearestDist = dist
							nearest = v
						end
					end
				end
			end
		end
	end

	return bossTarget or nearest
end

-- üõ°Ô∏è ƒê·∫£m b·∫£o ƒë·ª©ng ·ªü Y an to√†n (hover) ‚Äî tr·∫£ v·ªÅ v·ªã tr√≠ ƒë∆∞·ª£c n√¢ng Y l√™n hoverHeight n·∫øu c·∫ßn
local function ensureHoverPos(pos)
	-- d√≤ ray xu·ªëng ƒë·ªÉ t√¨m m·∫∑t ƒë·∫•t, n·∫øu kh√¥ng th·∫•y v·∫´n tr·∫£ v·ªÅ pos.y + hoverHeight
	local ray = Ray.new(pos + Vector3.new(0, 12, 0), Vector3.new(0, -60, 0))
	local hit, hitPos = Workspace:FindPartOnRay(ray)
	if hit and hitPos then
		return Vector3.new(pos.X, hitPos.Y + hoverHeight, pos.Z)
	else
		return Vector3.new(pos.X, pos.Y + hoverHeight, pos.Z)
	end
end

-- ‚ñ∑ MOVE: di chuy·ªÉn m∆∞·ª£t v√† "an to√†n" b·∫±ng chu·ªói tween t·ª´ng b∆∞·ªõc nh·ªè (tr√°nh anti-cheat)
local function moveSmoothlyTo(targetPos)
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if not (hum and root) then return end

	-- clamp targetPos Y ƒë·ªÉ kh√¥ng n·∫±m qu√° th·∫•p/ cao b·∫•t th∆∞·ªùng
	if targetPos.Y < -60 then
		targetPos = Vector3.new(targetPos.X, -10, targetPos.Z)
	end

	local current = root.Position
	local delta = targetPos - current
	local distance = delta.Magnitude
	if distance < 1 then
		-- n·∫øu r·∫•t g·∫ßn th√¨ set tr·ª±c ti·∫øp hover CFrame (nh·∫π nh√†ng)
		root.CFrame = CFrame.new(targetPos)
		return
	end

	local direction = delta.Unit
	local stepSize = tweenStep
	local steps = math.max(1, math.ceil(distance / stepSize))
	local timePerStep = math.clamp((stepSize / tweenSpeed), 0.04, 0.5) -- t·ªëi thi·ªÉu 0.04s m·ªói b∆∞·ªõc

	for i = 1, steps do
		if not _G.AutoTween then return end
		-- t√≠nh pos ti·∫øp theo (n·∫øu b∆∞·ªõc cu·ªëi th√¨ target ch√≠nh x√°c)
		local nextPos
		if i == steps then
			nextPos = targetPos
		else
			local move = direction * stepSize
			current = current + move
			nextPos = current
		end

		-- ƒë·∫£m b·∫£o Y hover an to√†n
		nextPos = ensureHoverPos(nextPos)

		-- tween linear ng·∫Øn
		local tweenInfo = TweenInfo.new(timePerStep, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
		local ok, tween = pcall(function()
			return TweenService:Create(root, tweenInfo, { CFrame = CFrame.new(nextPos) })
		end)
		if ok and tween then
			tween:Play()
			tween.Completed:Wait()
		else
			-- fallback: ƒë·∫∑t tr·ª±c ti·∫øp n·∫øu t·∫°o tween l·ªói
			root.CFrame = CFrame.new(nextPos)
			task.wait(timePerStep)
		end

		-- an to√†n: n·∫øu tr∆∞·ª£t ra kh·ªèi map th√¨ reset Y t·∫°m th·ªùi
		if root.Position.Y < -30 then
			root.CFrame = CFrame.new(root.Position.X, 5 + hoverHeight, root.Position.Z)
		end

		-- small buffer
		task.wait(0.02)
	end
end

-- ‚úàÔ∏è Teleport/di chuy·ªÉn g·∫ßn NPC tr∆∞·ªõc (pre-teleport) ‚Äî ƒë·∫∑t nhanh ·ªü kho·∫£ng preTeleportDistance
local function teleportNearTarget(target)
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	local _, tRoot = getHumanoidAndRoot(target)
	if not (hum and root and tRoot) then return end

	-- t√≠nh v·ªã tr√≠ n·∫±m tr∆∞·ªõc NPC c√°ch preTeleportDistance
	local dir = (tRoot.Position - root.Position)
	if dir.Magnitude == 0 then dir = Vector3.new(0,0,1) end
	local unitDir = dir.Unit
	local nearPos = tRoot.Position - unitDir * preTeleportDistance
	nearPos = ensureHoverPos(nearPos)
	-- set tr·ª±c ti·∫øp (teleport 1 l·∫ßn t·ªõi g·∫ßn) ‚Äî ƒë√¢y l√† kho·∫£ng c√°ch ƒë·ªß an to√†n
	root.CFrame = CFrame.new(nearPos, tRoot.Position)
end

-- ‚ú® Hover m∆∞·ª£t v√†o v·ªã tr√≠ sau l∆∞ng NPC b·∫±ng moveSmoothlyTo (thay v√¨ tween to l·ªõn)
local function hoverBehindTarget(npc)
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	local _, npcRoot = getHumanoidAndRoot(npc)
	if not (hum and root and npcRoot) then return end

	local behindPos = npcRoot.Position - npcRoot.CFrame.LookVector * behindDistance
	behindPos = Vector3.new(behindPos.X, behindPos.Y, behindPos.Z)
	behindPos = ensureHoverPos(behindPos)
	-- di chuy·ªÉn m∆∞·ª£t t·ª´ng b∆∞·ªõc nh·ªè ƒë·∫øn v·ªã tr√≠ hover
	moveSmoothlyTo(behindPos)

	-- kh√≥a hover c·ªë ƒë·ªãnh (g·∫∑p ph·∫£i set li√™n t·ª•c nh∆∞ng b·∫±ng CFrame nh·ªè)
	-- duy tr√¨ PlatformStand ƒë·ªÉ tr√°nh physics push
	if hum and hum.Health > 0 then
		hum.PlatformStand = true
	end
end

-- ‚ö° N√© skill: khi boss ph√°t hi·ªán animation "charge/attack" -> teleport nhanh v·ªÅ v·ªã tr√≠ safe ph√≠a sau (l√πi ra xa)
local function setupBossReaction(npc)
	local hum, root = getHumanoidAndRoot(npc)
	if not hum or not root then return end

	-- remove c≈©
	if npc:FindFirstChild("__ReactionConn") then
		local old = npc.__ReactionConn
		if old and type(old.Disconnect) == "function" then
			old:Disconnect()
		end
		npc.__ReactionConn = nil
	end

	-- k·∫øt n·ªëi theo d√µi animation (h·ª£p v·ªõi nhi·ªÅu boss d√πng AnimationPlayed)
	local conn = hum.AnimationPlayed:Connect(function(track)
		-- track l√† AnimationTrack object
		if not _G.AutoTween then return end
		if currentTarget ~= npc then return end
		if reacting then return end

		local animName = ""
		-- l·∫•y t√™n n·∫øu c√≥
		if track and track.Animation and track.Animation.Name then
			animName = tostring(track.Animation.Name):lower()
		end

		-- n·∫øu animation nghi ng·ªù l√† charge/attack -> l√πi tr√°nh
		if animName:find("attack") or animName:find("charge") or animName:find("slam") or animName:find("cast") or animName:find("telegraph") then
			reacting = true
			task.spawn(function()
				-- teleport l√πi ra xa (an to√†n) ‚Äî s·ª≠ d·ª•ng root.CFrame tr·ª±c ti·∫øp (1 l·∫ßn)
				local char = LocalPlayer.Character
				if not char then reacting = false return end
				local phum, proot = getHumanoidAndRoot(char)
				local _, npcRoot = getHumanoidAndRoot(npc)
				if phum and proot and npcRoot then
					local safePos = npcRoot.Position - npcRoot.CFrame.LookVector * (behindDistance + avoidDistance)
					safePos = ensureHoverPos(safePos)
					-- PH·∫¢I teleport 1 l·∫ßn ƒë·ªÉ tr√°nh ƒë√£ tween v·∫´n b·ªã hitbox
					proot.CFrame = CFrame.new(safePos, npcRoot.Position)
				end
				-- ch·ªù h·∫øt th·ªùi gian skill
				task.wait(1.2)
				reacting = false
			end)
		end
	end)

	npc.__ReactionConn = conn
end

-- üß≠ Ghi spawn point ƒë·ªÉ v·ªÅ khi map tr·ªëng
local function setSpawnPoint()
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if root then spawnPoint = root.Position end
end

local function returnToSpawn()
	if not spawnPoint then return end
	local char = LocalPlayer.Character
	if not char then return end
	local hum, root = getHumanoidAndRoot(char)
	if not root then return end
	local target = spawnPoint + Vector3.new(0, hoverHeight, 0)
	moveSmoothlyTo(target)
	if hum then
		hum.PlatformStand = true
	end
end

-- üîÅ Loop ch√≠nh (an to√†n)
task.spawn(function()
	-- ƒë·∫∑t ƒëi·ªÉm spawn ban ƒë·∫ßu
	setSpawnPoint()
	while true do
		task.wait(updateDelay)
		if not _G.AutoTween then
			task.wait(0.25)
		else
			-- n·∫øu ƒëang b·∫≠t auto
			local npc = getNearestTarget()
			if npc and isNPCReady(npc) then
				-- thi·∫øt l·∫≠p target m·ªõi
				if npc ~= currentTarget then
					currentTarget = npc
					-- c√†i reaction cho boss
					pcall(function() setupBossReaction(npc) end)
					-- teleport g·∫ßn (1 l·∫ßn) ƒë·ªÉ b·∫Øt ƒë·∫ßu di chuy·ªÉn m∆∞·ª£t
					pcall(function() teleportNearTarget(npc) end)
					-- ƒë·ª£i 0.4s ƒë·ªÉ server sync
					task.wait(0.4)
				end
				-- hover m∆∞·ª£t v√†o v·ªã tr√≠ sau l∆∞ng
				pcall(function() hoverBehindTarget(npc) end)
			else
				-- kh√¥ng c√≥ NPC ‚Üí v·ªÅ spawn v√† ch·ªù
				currentTarget = nil
				pcall(function() returnToSpawn() end)
			end
		end
	end
end)

-- ü™Ñ TOGGLE GUI (Th√™m v√†o Tab g·ªëc c·ªßa b·∫°n - gi·ªØ nguy√™n behavior toggle)
local ToggleFarm = Tab:CreateToggle({
	Name = "Auto Farm (Hover Safe + Full)",
	CurrentValue = false,
	Flag = "ToggleAutoFarm",
	Callback = function(Value)
		_G.AutoTween = Value
		local char = LocalPlayer.Character
		local hum, root = getHumanoidAndRoot(char)
		if not (hum and root) then return end

		if Value then
			-- b·∫≠t hover/kh√≥a v·∫≠t l√Ω
			pcall(function()
				hum.PlatformStand = true
				hum:ChangeState(Enum.HumanoidStateType.Physics)
			end)
			warn("[AUTO-FARM] ‚úÖ ƒê√£ b·∫≠t: Hover c·ªë ƒë·ªãnh + Farm to√†n map.")
		else
			-- t·∫Øt hover
			pcall(function()
				hum.PlatformStand = false
				hum:ChangeState(Enum.HumanoidStateType.GettingUp)
			end)
			-- cleanup
			currentTarget = nil
			reacting = false
			warn("[AUTO-FARM] ‚õî ƒê√£ t·∫Øt.")
		end
	end
})



local Toggle = MiscTab:CreateToggle({
	Name = "Auto Start",
	CurrentValue = false,
	Flag = "Toggle_AutoStart",
	Callback = function(Value)
		_G.AutoStart = Value

		if _G.AutoStart then
			warn("‚úÖ Auto Start ƒê√É B·∫¨T")

			-- üîÅ Ch·∫°y li√™n t·ª•c cho ƒë·∫øn khi t·∫Øt
			task.spawn(function()
            repeat task.wait() until _G.ComboDone == true

				while _G.AutoStart do
					-- ‚ö° G·ª≠i l·ªánh start
					game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer()
					warn("üîÅ Auto Start ƒëang th·ª±c thi...")

					-- ‚è± Ch·ªù 1‚Äì2 gi√¢y ƒë·ªÉ tr√°nh spam server
					task.wait(2)
				end
				warn("‚õî Auto Start ƒê√É D·ª™NG")
			end)

		else
			warn("‚õî Auto Start ƒê√É T·∫ÆT TH·ª¶ C√îNG")
		end
	end,
})


--// üß© Auto Bonus Boss
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local dataRemoteEvent = ReplicatedStorage:WaitForChild("dataRemoteEvent")

_G.AutoBonusBoss = false

local AutoBonus = MiscTab:CreateToggle({
    Name = "Auto Bonus Boss",
    CurrentValue = false,
    Flag = "AutoBonusBoss",
    Callback = function(Value)
        _G.AutoBonusBoss = Value
        if Value then
            task.spawn(function()
                while _G.AutoBonusBoss do
                    task.wait(1)
                    local bonusAvailable = false

                    -- Ki·ªÉm tra n·∫øu server c√≥ th·ªÉ vote "bonus"
                    for _, remote in pairs(ReplicatedStorage:GetChildren()) do
                        if remote.Name == "dataRemoteEvent" then
                            bonusAvailable = true
                            break
                        end
                    end

                    -- N·∫øu c√≥ bonus ‚Üí vote bonus
                    if bonusAvailable then
                        dataRemoteEvent:FireServer({
                            {
                                ["\3"] = "vote",
                                vote = "bonus"
                            },
                            "-"
                        })
                        task.wait(1) -- ch·ªù x√≠u ƒë·ªÉ bonus x·ª≠ l√Ω xong
                    end
                end
            end)
        end
    end,
})

--// ‚öôÔ∏è T√≠ch h·ª£p ∆∞u ti√™n AutoBonusBoss tr∆∞·ªõc AutoRetry
-- Gi·∫£ s·ª≠ AutoRetry c√≥ bi·∫øn _G.AutoRetry
task.spawn(function()
    while task.wait(1) do
        if _G.AutoRetry then
            if _G.AutoBonusBoss then
                -- N·∫øu bonus c√≥ s·∫µn th√¨ ∆∞u ti√™n vote tr∆∞·ªõc khi retry
                local bonusAvailable = false
                for _, remote in pairs(ReplicatedStorage:GetChildren()) do
                    if remote.Name == "dataRemoteEvent" then
                        bonusAvailable = true
                        break
                    end
                end

                if bonusAvailable then
                    dataRemoteEvent:FireServer({
                        {
                            ["\3"] = "vote",
                            vote = "bonus"
                        },
                        "-"
                    })
                    task.wait(1.5) -- ƒê·ª£i x·ª≠ l√Ω bonus
                end
            end

            -- Ti·∫øp t·ª•c auto retry b√¨nh th∆∞·ªùng
            pcall(function()
                local retryRemote = ReplicatedStorage:FindFirstChild("retryRemoteEvent") or ReplicatedStorage:FindFirstChild("Retry")
                if retryRemote then
                    retryRemote:FireServer()
                end
            end)
        end
    end
end)



local Toggle = MiscTab:CreateToggle({
	Name = "Auto Retry",
	CurrentValue = false,
	Flag = "Toggle_AutoRetry",
	Callback = function(Value)
		_G.AutoRetry = Value

		if _G.AutoRetry then
			warn("‚úÖ Auto Retry ƒê√É B·∫¨T")

			-- üîÅ Ch·∫°y li√™n t·ª•c cho ƒë·∫øn khi t·∫Øt
			task.spawn(function()
				while _G.AutoRetry do
					-- ‚ö° G·ª≠i l·ªánh retry
					local args = {
                        [1] = {
                            [1] = {
                                ["\3"] = "vote",
                                ["vote"] = true
                            },
                            [2] = "-"
                        }
                    }

                    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
					warn("üîÅ Auto Retry ƒëang th·ª±c thi...")

					-- ‚è± Ch·ªù 1‚Äì2 gi√¢y ƒë·ªÉ tr√°nh spam server
					task.wait(2)
				end
				warn("‚õî Auto Retry ƒê√É D·ª™NG")
			end)

		else
			warn("‚õî Auto Retry ƒê√É T·∫ÆT TH·ª¶ C√îNG")
		end
	end,
})

---- ‚öôÔ∏è FIX LAG (T√≠ch h·ª£p v√†o Misc Tab)
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local active = false
local saved = {}

-- üåà L∆∞u c·∫•u h√¨nh √°nh s√°ng g·ªëc
local function saveOriginal()
    saved.Lighting = {
        Technology = Lighting.Technology,
        GlobalShadows = Lighting.GlobalShadows,
        Brightness = Lighting.Brightness,
        FogEnd = Lighting.FogEnd
    }
end

-- üîÑ Kh√¥i ph·ª•c c·∫•u h√¨nh √°nh s√°ng g·ªëc
local function restoreOriginal()
    if not saved.Lighting then return end
    Lighting.Technology = saved.Lighting.Technology
    Lighting.GlobalShadows = saved.Lighting.GlobalShadows
    Lighting.Brightness = saved.Lighting.Brightness
    Lighting.FogEnd = saved.Lighting.FogEnd
end

-- üí® H√†m gi·∫£m hi·ªáu ·ª©ng t·ª´ng ƒë·ªëi t∆∞·ª£ng
local function minimize(obj)
    if obj:IsA("ParticleEmitter") or obj:IsA("Beam") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
        obj.Enabled = false
    end

    if obj:IsA("Explosion") then
        obj.Visible = false
    end

    if obj:IsA("BasePart") then
        obj.Material = Enum.Material.SmoothPlastic
        obj.Reflectance = 0
        obj.CastShadow = false
        obj.Color = Color3.fromRGB(200,200,200)
    end

    if obj:IsA("Decal") or obj:IsA("Texture") then
        obj.Transparency = 1
    end

    if obj:IsA("Sound") then
        obj.Volume = 0
        obj:Stop()
    end

    if obj:IsA("Light") then
        obj.Enabled = false
    end
end

-- üöÄ √Åp d·ª•ng ch·∫ø ƒë·ªô gi·∫£m lag
local function applyLiteMode()
    Lighting.Technology = Enum.Technology.Compatibility
    Lighting.GlobalShadows = false
    Lighting.Brightness = 1
    Lighting.FogEnd = 999999999

    for _, obj in ipairs(Workspace:GetDescendants()) do
        minimize(obj)
    end

    Workspace.DescendantAdded:Connect(function(obj)
        if active then minimize(obj) end
    end)
end

-- üß© B·∫≠t/T·∫Øt FixLag
local function toggleFixLag(on)
    active = on
    if on then
        saveOriginal()
        applyLiteMode()
        warn("‚úÖ Fix Lag LITE: ON")
    else
        restoreOriginal()
        warn("‚õî Fix Lag LITE: OFF (b·∫°n c√≥ th·ªÉ c·∫ßn rejoin ƒë·ªÉ kh√¥i ph·ª•c ho√†n to√†n)")
    end
end

-- üéõÔ∏è Th√™m Toggle v√†o Misc Tab
local ToggleFixLag = MiscTab:CreateToggle({
    Name = "Fix Lag (Lite Mode)",
    CurrentValue = false,
    Flag = "Toggle_FixLag",
    Callback = function(Value)
        toggleFixLag(Value)
    end,
})





local WalkspeedInput = MiscTab:CreateInput({
    Name = "Walkspeed Input",
    PlaceholderText = "Nh·∫≠p t·ªëc ƒë·ªô (VD: 100)",
    CurrentValue = "16",
    RemoveTextAfterFocusLost = false,
    Flag = "Walkspeed_Input",

    Callback = function(Text)
        local Speed = tonumber(Text)
        if not Speed then
            warn("‚ùå H√£y nh·∫≠p s·ªë h·ª£p l·ªá!")
            return
        end

        Speed = math.clamp(Speed, 0, 300)

        local player = game.Players.LocalPlayer
        local humanoid = player and player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = Speed
            warn("‚úÖ ƒê·∫∑t t·ªëc ƒë·ªô th√†nh:", Speed)
        end
    end,
})

-- üß† Th√™m s·ª± ki·ªán auto-clear khi click v√†o textbox
task.spawn(function()
    task.wait(1) -- ƒë·ª£i UI load xong
    local box = WalkspeedInput.InputBox or WalkspeedInput.TextBox or WalkspeedInput

    if box and box.FocusGained then
        box.FocusGained:Connect(function()
            box.Text = "" -- xo√° n·ªôi dung hi·ªán t·∫°i khi click v√†o
        end)
    else
        warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y TextBox (c√≥ th·ªÉ UI lib c·ªßa b·∫°n d√πng t√™n kh√°c)")
    end
end)

-- üß† T·ª± ƒë·ªông kh√¥i ph·ª•c l·∫°i tr·∫°ng th√°i Toggle/Input khi m·ªü l·∫°i game
task.spawn(function()
    task.wait(1) -- ƒë·ª£i UI load ho√†n t·∫•t
    Rayfield.LoadConfiguration() -- kh√¥i ph·ª•c m·ªçi gi√° tr·ªã ƒë√£ l∆∞u
end)
